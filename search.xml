<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>restful-api</title>
      <link href="/2020/01/20/restful-api/"/>
      <url>/2020/01/20/restful-api/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是restful-api"><a href="#什么是restful-api" class="headerlink" title="什么是restful api?"></a>什么是<code>restful api</code>?</h4><blockquote><p>restful api是用于在前端与后台进行通信的一套规范。使用这个规范可以让前后端开发变得更加轻松。</p></blockquote><p><code>restful api</code>的 <code>设计规范</code>：</p><h4 id="1、协议："><a href="#1、协议：" class="headerlink" title="1、协议："></a>1、协议：</h4><blockquote><p>采用http或者https协议。</p></blockquote><h4 id="2、数据传输格式："><a href="#2、数据传输格式：" class="headerlink" title="2、数据传输格式："></a>2、数据传输格式：</h4><blockquote><p>数据之间传输的格式应该都使用json，而不使用xml。</p></blockquote><h4 id="3、url链接："><a href="#3、url链接：" class="headerlink" title="3、url链接："></a>3、url链接：</h4><blockquote><p>url链接中，不能有动词，只能有名词。并且对于一些名词，如果出现复数，那么应该在后面加s。<br>比如：获取文章列表，应该使用<code>/articles/</code>，而不应该使用/get_article/</p></blockquote><h4 id="4、HTTP请求的方法："><a href="#4、HTTP请求的方法：" class="headerlink" title="4、HTTP请求的方法："></a>4、HTTP请求的方法：</h4><blockquote><p>GET：从服务器上获取资源。<br>POST：在服务器上新创建一个资源。<br>PUT：在服务器上更新资源。（客户端提供所有改变后的数据）<br>PATCH：在服务器上更新资源。（客户端只提供需要改变的属性）<br>DELETE：从服务器上删除资源。<br>示例如下：<br>GET /users/：获取所有用户。<br>POST /user/：新建一个用户。<br>GET /user/id/：根据id获取一个用户。<br>PUT /user/id/：更新某个id的用户的信息（需要提供用户的所有信息）。<br>PATCH /user/id/：更新某个id的用户信息（只需要提供需要改变的信息）。<br>DELETE /user/id/：删除一个用户。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11624186-ef5819baf7f2636e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码"></p><h4 id="常见的python-restful-api框架"><a href="#常见的python-restful-api框架" class="headerlink" title="常见的python restful api框架"></a>常见的python restful api框架</h4><p>1、flask-restful<br>2、Django REST framework<br>3、fastapi（集成度比较高，可以直接编写，还有集成了<code>swagger</code>作为api文档）<br><code>注：不管是哪一种开发框架，restful api的思想还是一样的道理</code></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> restful-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之运算符</title>
      <link href="/2020/01/03/go-yu-yan-ji-chu-zhi-yun-suan-fu/"/>
      <url>/2020/01/03/go-yu-yan-ji-chu-zhi-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Go 语言内置的运算符有：</p><p>1、算术运算符<br>2、关系运算符<br>3、逻辑运算符<br>4、位运算符<br>5、赋值运算符</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><img src="https://github.com/lvyunze/image/raw/master/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/1.png" alt="算数运算符"></p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p><img src="https://github.com/lvyunze/image/raw/master/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/2.png" alt></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="https://github.com/lvyunze/image/raw/master/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/3.png" alt></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="https://github.com/lvyunze/image/raw/master/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/4.png" alt></p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><img src="https://github.com/lvyunze/image/raw/master/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 每日go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础之运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础之变量和常量</title>
      <link href="/2020/01/03/go-yu-yan-ji-chu-zhi-bian-liang-he-chang-liang/"/>
      <url>/2020/01/03/go-yu-yan-ji-chu-zhi-bian-liang-he-chang-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><pre><code>break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return       var</code></pre><p>此外，Go语言中还有37个保留字。</p><pre><code>Constants:    true  false  iota  nilTypes:    int  int8  int16  int32  int64            uint  uint8  uint16  uint32  uint64  uintptr          float32  float64  complex128  complex64          bool  byte  rune  string  errorFunctions:   make  len  cap  new  append  copy  close  delete         complex  real  imag         panic  recover</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h4><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h4 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h4><p>Go语言的变量声明格式为：</p><pre><code>var 变量名 变量类型</code></pre><p>变量声明以关键字<strong>var</strong>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><pre><code>var name stringvar age intvar isOk bool</code></pre><h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><p>每声明一个变量就需要写<strong>var</strong>关键字会比较繁琐，go语言中还支持批量变量声明：</p><pre><code>var (    a string    b int    c bool    d float32)</code></pre><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下</p><pre><code>var 变量名 类型 = 表达式</code></pre><p>举个例子：</p><pre><code>var name string = &quot;Q1mi&quot;var age int = 18</code></pre><p>或者一次初始化多个变量</p><pre><code>var name, age = &quot;Q1mi&quot;, 20</code></pre><h5 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h5><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><pre><code>var name = &quot;Q1mi&quot;var age = 18</code></pre><h5 id="短变量的声明"><a href="#短变量的声明" class="headerlink" title="短变量的声明"></a>短变量的声明</h5><p>在函数内部，可以使用更简略的 := 方式声明并初始化变量。</p><pre><code>package mainimport (    &quot;fmt&quot;)// 全局变量mvar m = 100func main() {    n := 10    m := 200 // 此处声明局部变量m    fmt.Println(m, n)}</code></pre><h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><p>在使用多重赋值时，如果想要忽略某个值，可以使用<strong>匿名变量（anonymous variable）</strong>。 匿名变量用一个下划线<strong>_</strong>表示，例如：</p><pre><code>func foo() (int, string) {    return 10, &quot;Q1mi&quot;}func main() {    x, _ := foo()    _, y := foo()    fmt.Println(&quot;x=&quot;, x)    fmt.Println(&quot;y=&quot;, y)}</code></pre><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。(在Lua等编程语言里，匿名变量也被叫做哑元变量。)<br>注意事项：<br>1、函数外的每个语句都必须以关键字开始（var、const、func等）<br>2、:=不能使用在函数外。<br>3、_多用于占位，表示忽略值。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了<strong>const</strong>，常量在定义的时候必须赋值。</p><pre><code>const pi = 3.1415const e = 2.7182</code></pre><p>声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><pre><code>const (    pi = 3.1415    e = 2.7182)</code></pre><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><pre><code>const (    n1 = 100    n2    n3)</code></pre><p>上面示例中，常量n1、n2、n3的值都是100。</p><h5 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h5><p><strong>iota</strong>是go语言的常量计数器，只能在常量的表达式中使用。</p><p>iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><pre><code>const (        n1 = iota //0        n2        //1        n3        //2        n4        //3    )</code></pre><h6 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的iota示例:</h6><p>使用_跳过某些值</p><pre><code>const (        n1 = iota //0        n2        //1        _        n4        //3    )</code></pre><p>iota声明中间插队</p><pre><code>const (        n1 = iota //0        n2 = 100  //100        n3 = iota //2        n4        //3    )    const n5 = iota //0</code></pre><p>定义数量级 （这里的&lt;&lt;表示左移操作，1&lt;&lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&lt;&lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）</p><pre><code>const (        _  = iota        KB = 1 &lt;&lt; (10 * iota)        MB = 1 &lt;&lt; (10 * iota)        GB = 1 &lt;&lt; (10 * iota)        TB = 1 &lt;&lt; (10 * iota)        PB = 1 &lt;&lt; (10 * iota)    )</code></pre><p>多个iota定义在一行</p><pre><code>const (        a, b = iota + 1, iota + 2 //1,2        c, d                      //2,3        e, f                      //3,4    )</code></pre><p>来源：<a href="https://www.liwenzhou.com/posts/Go/01_var_and_const/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/01_var_and_const/</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础之变量和常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go初探</title>
      <link href="/2020/01/03/go-chu-tan/"/>
      <url>/2020/01/03/go-chu-tan/</url>
      
        <content type="html"><![CDATA[<h4 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h4><p><img src="https://github.com/lvyunze/image/raw/master/go%E5%88%9D%E6%8E%A2/1.png" alt="GOPATH"></p><h4 id="Go项目结构"><a href="#Go项目结构" class="headerlink" title="Go项目结构"></a>Go项目结构</h4><p><img src="https://github.com/lvyunze/image/raw/master/go%E5%88%9D%E6%8E%A2/3.png" alt></p><h4 id="适合个人开发者"><a href="#适合个人开发者" class="headerlink" title="适合个人开发者"></a>适合个人开发者</h4><p><img src="https://github.com/lvyunze/image/raw/master/go%E5%88%9D%E6%8E%A2/4.png" alt></p><h4 id="目前流行的项目结构"><a href="#目前流行的项目结构" class="headerlink" title="目前流行的项目结构"></a>目前流行的项目结构</h4><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用<strong>顶级域名</strong>来作为包名的前缀，这样就不担心项目名冲突的问题了。</p><p>因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的<strong>github用户名</strong>来区分不同的包。<br><img src="https://github.com/lvyunze/image/raw/master/go%E5%88%9D%E6%8E%A2/5.png" alt="目前流行的项目结构"></p><p>举个例子：张三和李四都有一个名叫studygo的项目，那么这两个包的路径就会是：</p><pre><code>mport &quot;github.com/lisi/studygo&quot;</code></pre><p>以后我们从github上下载别人包的时候，如：</p><pre><code>go get github.com/jmoiron/sqlx</code></pre><p>那么，这个包会下载到我们<strong>本地GOPATH</strong>目录下的<strong>src/github.com/jmoiron/sqlx</strong>。</p><h4 id="适合企业开发场景"><a href="#适合企业开发场景" class="headerlink" title="适合企业开发场景"></a>适合企业开发场景</h4><p><img src="https://github.com/lvyunze/image/raw/master/go%E5%88%9D%E6%8E%A2/6.png" alt="适合企业开发场景"></p><h4 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h4><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>现在我们来创建第一个Go项目——hello。在我们的GOPATH下的src目录中创建hello目录。</p><p>在该目录中创建一个main.go文件：</p><pre><code>package main  // 声明 main 包，表明当前是一个可执行程序import &quot;fmt&quot;  // 导入内置 fmt 包func main(){  // main函数，是程序执行的入口    fmt.Println(&quot;Hello World!&quot;)  // 在终端打印 Hello World!}</code></pre><h5 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h5><p><strong>go build</strong>表示将源代码编译成可执行文件。</p><p>在hello目录下执行：</p><pre><code>go build</code></pre><p>或者在其他目录执行以下命令：</p><pre><code>go build hello</code></pre><p>go编译器会去 <strong>GOPATH的src目录</strong>下查找你要编译的hello项目</p><p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到hello.exe可执行文件。</p><p>可在终端直接执行该hello.exe文件：</p><pre><code>d:\code\go\src\hello&gt;hello.exeHello World!</code></pre><p>我们还可以使用*<em>-o</em>8参数来指定编译后得到的可执行文件的名字。</p><pre><code>go build -o heiheihei.exe</code></pre><h5 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h5><p><strong>go install</strong> 表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到GOPATH的bin目录下。因为我们的环境变量中配置了<strong>GOPATH</strong>下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。</p><h4 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h4><p>默认我们的<strong>go build</strong>的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？</p><p>只需要指定目标操作系统的平台和处理器架构即可：</p><pre><code>SET CGO_ENABLED=0  // 禁用CGOSET GOOS=linux  // 目标平台是linuxSET GOARCH=amd64  // 目标处理器架构是amd64</code></pre><p>使用了cgo的代码是不支持跨平台编译的</p><p>然后再执行go build命令，得到的就是能够在Linux平台运行的可执行文件了。</p><p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p><pre><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go buildCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</code></pre><p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p><pre><code>CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go buildCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</code></pre><p>Windows下编译Mac平台64位可执行程序：</p><pre><code>SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build```来源:https://www.liwenzhou.com/posts/Go/01_var_and_const/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go初探 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker与openstack融合、docker与k8s</title>
      <link href="/2019/10/25/docker-yu-openstack-rong-he-docker-yu-k8s/"/>
      <url>/2019/10/25/docker-yu-openstack-rong-he-docker-yu-k8s/</url>
      
        <content type="html"><![CDATA[<h3 id="目前有几个可能的方向"><a href="#目前有几个可能的方向" class="headerlink" title="目前有几个可能的方向"></a>目前有几个可能的方向</h3><blockquote><p>1、是把docker封装一层，变成类似kvm的虚拟机引擎。<br>把docker封装成虚拟机引擎，这是一个看起来比较有效和直接的溶合了docker的方案，但，是有问题的，必竟它不是虚拟机，没有实现虚拟机那样对资源彻底的隔离，所以你登录到docker虚拟出来的容器和登录到kvm等虚拟机引擎虚拟出来的虚机上时虽然感觉差不多，但一些涉及到相对低层的命令的执行结果是不一致的。所以docker不是一个好的虚拟机引擎，因为它就不是虚拟机引擎。另一方面，这种方式的集成会屏蔽docker在部署上的优势。所以如果Openstack要全面的溶合docker,那它就不是现在的openstack了，它就不是IaaS层的东东了</p></blockquote><blockquote><p>2、是把docker运行到openstack管理的虚拟机中。<br>把docker运行到openstack管理的虚拟机中，这是虚拟中的虚拟，有点黑客帝国的味道或盗梦空间？土豪的节奏啊，简直浪费资源。</p></blockquote><blockquote><p>3、是把openstack用到的各个组件装到docker容器，方便部署。我们来仔细分析一下这几个可能的方向。<br>把openstack用到的各个组件装到docker容器上，这个不错，正好是对docker的很好的使用，证明了docker的能力</p></blockquote><blockquote><p>docker会取代openstack吗？<br>不知道，但是以docker为代表的容器技术应该会极大的压缩openstack在虚拟机方面的使用空间，哦对了，openstack还会管理网络和存储。但是需要它管理吗，不需要吗。必须要用windows的情况下还是不能用docker的，因为这一点，docker也会一定层度上拉升在服务器领域的linux操作系统占有率。一些需要强硬件资源隔离的场景下还是使用openstack之类的技术的。</p></blockquote><h3 id="docker与k8s"><a href="#docker与k8s" class="headerlink" title="docker与k8s"></a>docker与k8s</h3><blockquote><p>Kubernetes（K8s）：搭建容器集群和进行容器编排的主流开源项目（亲爹是Google），适合搭建PaaS平台。容器是Kubernetes管理的核心目标对象，它和容器的关系就好比OpenStack和虚拟机之间的关系，而它和Docker的关系就好比OpenStack和Hypervisor之间的关系。一般来说，Kubernetes是和Docker配合使用的，Kubernetes调用每个节点上的Docker去创建和管理容器，所以，可以认为Kubernetes是大脑，而Docker是四肢。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> docker与k8s </tag>
            
            <tag> openstack与docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2019/10/25/rabbitmq/"/>
      <url>/2019/10/25/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p><img src="https://github.com/lvyunze/image/blob/master/RabbitMQ/1.png?raw=true" alt></p><p><strong>RabbitMQ是消息代理(Message Broker)</strong>，它支持多种异步消息处理方式，最常见的有：</p><p>Work Queue：将消息缓存到一个队列，默认情况下，多个worker按照Round Robin的方式处理队列中的消息。每个消息只会分配给单个worker。<br>Publish/Subscribe：每个订阅消息的消费者都会收到消息，因此每个消息通常会分配给多个worker，每个worker对消息进行不同的处理。</p><p>RabbitMQ还支持Routing、Topics、以及Remote procedure calls (RPC)等方式。<br>对于不同的消息处理方式，有一点是相同的，RabbitMQ是介于消息的生产者和消费者的中间节点，负责缓存和分发消息。RabbitMQ接收来自生产者的消息，缓存到内存中，按照不同的方式分发给消费者。RabbitMQ还可以将消息写入磁盘，保证持久化，这样即使RabbitMQ意外崩溃了，消息数据不至于完全丢失。</p><h3 id="为什么使用RabbitMQ？"><a href="#为什么使用RabbitMQ？" class="headerlink" title="为什么使用RabbitMQ？"></a>为什么使用RabbitMQ？</h3><p>最简单的一点在于，它支持Work Queue等不同的消息处理方式，可以用于不同的业务场景。<br>使用消息队列，可以将不算紧急、但是非常消耗资源的计算任务，以消息的方式插入到RabbitMQ的队列中，然后使用多个处理模块处理这些消息。<br>这样做最大的好处在于：提高了系统峰值处理能力。因为，来不及处理的消息缓存在RabbitMQ中，避免了同时进行大量计算导致系统因超负荷运行而崩溃。而那些来不及处理的消息，会在峰值过去之后慢慢处理掉。<br>另一个好处在于解耦。消息的生产者只需要将消息发送给RabbitMQ，这些消息什么时候处理完，不会影响生产者的响应性能。<br><img src="https://github.com/lvyunze/image/blob/master/RabbitMQ/2.png?raw=true" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openstack核心组件</title>
      <link href="/2019/10/25/openstack-he-xin-zu-jian/"/>
      <url>/2019/10/25/openstack-he-xin-zu-jian/</url>
      
        <content type="html"><![CDATA[<p><img src alt></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openstack之nova</title>
      <link href="/2019/10/18/openstack-zhi-nova/"/>
      <url>/2019/10/18/openstack-zhi-nova/</url>
      
        <content type="html"><![CDATA[<p>在云平台的建设中，最重要的就是云平台资源的合理利用和部署的自动化，我们在搭建云平台的时候会虚拟出多个虚拟机来对外对内提供服务，但是如果将所有的服务器进行物理划分构建出来很多虚拟机让其一直开着会照成一些问题，如：</p><ol><li><p>资源的利用，也就是有的虚拟机比没有在使用，但还在运行</p></li><li><p>部署的麻烦，也就是说我们按照计划的划分方法，创建出来计划个数的虚拟机，这样在人力上一定不是最明智</p></li><li><p>虚拟机的管理不方便，这么多的虚拟机在提供服务，我们需要一个系统来统一管理这些虚拟机的启动关闭等<br>所以，我们就需要一个虚拟机的管理系统，open stack，他可以很好的将虚拟机轻量化，就像k8s调度docker image一样，它可以调度虚拟机image的创建，删除，迁移等，也就是说，我们不用配置每一个虚拟机，它可以将虚拟机像image一样进行复制，创建，并且会记录下来当前该虚拟机的状态，再次启动时，还会恢复到原来虚拟机的状态，同时他还会感知集群负载的情况，保证了集群的负载均衡。</p></li></ol><p>对于open stack来说它有三大组件：Nova、Quantum、Swift，在三大组件中，Nova主要负责Computer模块，也就是调度管理虚拟机的创建、启动、删除等，Quantum负责虚拟网络，而Swift主要负责云存储。由此可见，Nova是占据主要核心位置的。下面我们就来讨论一下Nova。</p><p>Nova主要负责了云中虚拟机的管理，举个例子，对于自来水公司而言，主要提供的资源是水，而水的运输是通过水管，因此，水管的铺设及管理系统是是十分重要的，类比一下：物理资源就相当于水，虚拟机相当于管道，Nova就相当于管道的管理系统。下面我们慢慢介绍一下Nova的架构：<br>最简单的基础架构:<br><img src="https://github.com/lvyunze/image/blob/master/openstack%E4%B9%8Bnova/1.png?raw=true" alt></p><p><strong>Nova-API：负责接收来自客户端的http请求，比如创建一个虚拟机。</strong></p><p><strong>Nova-scheduler：负责选择合适的服务器节点，这里的调度策略是先过滤不合适的节点，然后再进行打分操作，选择出来最合适的节点通知该节点上的nova-computer来进行创建虚拟机、迁移等操作。</strong></p><p><strong>Nova-computer：以一个守护进程的方式运行在计算节点上，专门负责创建虚拟机。</strong></p><blockquote><p>但是这是最简单的架构模型，我们想，nova-computer在创建虚拟机的时候，需要给虚拟机准备文件系统，那么这就需要用到nova-volume（概念如下）<br>nova-volume：为虚拟机提供块设备存储，也就是说，它主要负责创建云硬盘、删除云硬盘。大部分功能已被Cinder替代。<br>在准备好文件系统的时候，我们还需要给虚拟机分配合适的IP地址等网络设备，保证其有一个稳定的网络通讯，那么这就需要用到nova-network（概念如下）</p></blockquote><p><strong>nova-network：为虚拟机提供网络服务，也就是说，它实现了网络资源池的管理，包括：IP池、网桥接口、防火墙、VLAN等的管理。大部分功能已被Quantum替代。</strong></p><blockquote><p>我们考虑一个同步和异步的问题，如果nova-API在接受到客户端的http请求之后，向nova-scheduler发送消息，那么这就是同步操作，如果整体的操作都是同步的情况，也就是说，在一个请求操作没有完成之前，所有模块都会停在这里不能做其他的工作，这必然会照成工作效率的下降，同时，各个模块之间的关系过于密切，一个模块失效的时候，其他的就无法完成工作，因为消息无法传递下去，所以为了降低各个模块的耦合性同时保证操作的异步性，这里用到了消息队列机制，RabbitMQ（概念如下）</p></blockquote><p>**RabbitMQ：消息队列机制的实现，各个nova模块之间的通信几乎通过该队列实现，为各个模块传递消息。比如，nova-API在接受到http请求的时候，他会将该请求放到RabbitMQ中，nova-scheduler、nova-volume、nova-network等会从RabbitMQ队列中获取相应的任务去执行。</p><p>在解决了消息传递的机制之后，我们会不会觉得这个架构中还缺少一个东西，对，就是一个存储各个模块所需要必要信息的数据库，这里我们一般使用Mysql、Postgres的等数据库，各个模块都可以通过该数据库来查询自己必要的信息，并且也可以往数据库中记录一些更改等信息。这里就有了一个nova database（概念如下）</p><p><strong>nova-database：用于存储各个模块所需要的必要的信息。一般用Mysql即可。</strong><br>由于这个数据库中存储了各个模块的必要信息，那么里面的数据信息还是十分重要的，由于nova-computer是存在于每一个节点上的，那么如果攻破了一个节点，那么，就可以直接访问该数据库，危险性可想而知，所以，为了防止该情况的出现，nova-conductor的出现很好的解决了这个问题（概念如下）</p><p><strong>nova-conductor：介于nova-database和nova-computer之间，其目的在于消除nova-compuer直接访问云数据库。保证了数据库的安全性。</strong></p><p>那么，通过上面的介绍，是不是已经自动的将nova的架构图补全了呢，那么下面就是nova的完整架构图：<br><img src="https://github.com/lvyunze/image/blob/master/openstack%E4%B9%8Bnova/2.png?raw=true" alt></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openstack </tag>
            
            <tag> nova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas速查手册</title>
      <link href="/2019/09/12/pandas-su-cha-shou-ce/"/>
      <url>/2019/09/12/pandas-su-cha-shou-ce/</url>
      
        <content type="html"><![CDATA[<p><strong>关键缩写和包导入</strong><br>在这个速查手册中，我们使用如下缩写：</p><blockquote><p>df：任意的Pandas DataFrame对象<br>s：任意的Pandas Series对象</p></blockquote><p>同时我们需要做如下的引入：</p><blockquote><p>import pandas as pd<br>import numpy as np</p></blockquote><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><pre><code>pd.read_csv(filename)：从CSV文件导入数据pd.read_table(filename)：从限定分隔符的文本文件导入数据pd.read_excel(filename)：从Excel文件导入数据pd.read_sql(query, connection_object)：从SQL表/库导入数据pd.read_json(json_string)：从JSON格式的字符串导入数据pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据</code></pre><h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><pre><code>df.to_csv(filename)：导出数据到CSV文件df.to_excel(filename)：导出数据到Excel文件df.to_sql(table_name, connection_object)：导出数据到SQL表df.to_json(filename)：以Json格式导出数据到文本文件</code></pre><h3 id="创建测试对象"><a href="#创建测试对象" class="headerlink" title="创建测试对象"></a>创建测试对象</h3><pre><code>pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象pd.Series(my_list)：从可迭代对象my_list创建一个Series对象df.index = pd.date_range(&#39;1900/1/30&#39;, periods=df.shape[0])：增加一个日期索引</code></pre><h3 id="查看、检查数据"><a href="#查看、检查数据" class="headerlink" title="查看、检查数据"></a>查看、检查数据</h3><pre><code>df.head(n)：查看DataFrame对象的前n行df.tail(n)：查看DataFrame对象的最后n行df.shape()：查看行数和列数http://df.info()：查看索引、数据类型和内存信息df.describe()：查看数值型列的汇总统计s.value_counts(dropna=False)：查看Series对象的唯一值和计数df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</code></pre><h3 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h3><pre><code>df[col]：根据列名，并以Series的形式返回列df[[col1, col2]]：以DataFrame形式返回多列s.iloc[0]：按位置选取数据s.loc[&#39;index_one&#39;]：按索引选取数据df.iloc[0,:]：返回第一行df.iloc[0,0]：返回第一列的第一个元素</code></pre><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><pre><code>df.columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]：重命名列名pd.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组pd.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组df.dropna()：删除所有包含空值的行df.dropna(axis=1)：删除所有包含空值的列df.dropna(axis=1,thresh=n)：删除所有小于n个非空值的行df.fillna(x)：用x替换DataFrame对象中所有的空值s.astype(float)：将Series中的数据类型更改为float类型s.replace(1,&#39;one&#39;)：用‘one’代替所有等于1的值s.replace([1,3],[&#39;one&#39;,&#39;three&#39;])：用&#39;one&#39;代替1，用&#39;three&#39;代替3df.rename(columns=lambda x: x + 1)：批量更改列名df.rename(columns={&#39;old_name&#39;: &#39;new_ name&#39;})：选择性更改列名df.set_index(&#39;column_one&#39;)：更改索引列df.rename(index=lambda x: x + 1)：批量重命名索引</code></pre><h3 id="数据处理：Filter、Sort和GroupBy"><a href="#数据处理：Filter、Sort和GroupBy" class="headerlink" title="数据处理：Filter、Sort和GroupBy"></a>数据处理：Filter、Sort和GroupBy</h3><pre><code>df[df[col] &gt; 0.5]：选择col列的值大于0.5的行df.sort_values(col1)：按照列col1排序数据，默认升序排列df.sort_values(col2, ascending=False)：按照列col1降序排列数据df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据df.groupby(col)：返回一个按列col进行分组的Groupby对象df.groupby([col1,col2])：返回一个按多列进行分组的Groupby对象df.groupby(col1)[col2]：返回按列col1进行分组后，列col2的均值df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值data.apply(np.mean)：对DataFrame中的每一列应用函数np.meandata.apply(np.max,axis=1)：对DataFrame中的每一行应用函数np.max</code></pre><h3 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h3><pre><code>df1.append(df2)：将df2中的行添加到df1的尾部pd.concat([df1, df2],axis=1)：将df2中的列添加到df1的尾部df1.join(df2,on=col1,how=&#39;inner&#39;)：对df1的列和df2的列执行SQL形式的join</code></pre><h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><pre><code>df.describe()：查看数据值列的汇总统计df.mean()：返回所有列的均值df.corr()：返回列与列之间的相关系数df.count()：返回每一列中的非空值的个数df.max()：返回每一列的最大值df.min()：返回每一列的最小值df.median()：返回每一列的中位数df.std()：返回每一列的标准差</code></pre>]]></content>
      
      
      <categories>
          
          <category> python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas速查手册 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openstack梳理</title>
      <link href="/2019/09/12/openstack-shu-li/"/>
      <url>/2019/09/12/openstack-shu-li/</url>
      
        <content type="html"><![CDATA[<p>OpenStack既是一个社区，也是一个项目和一个开源软件，提供开放源码软件，建立公共和私有云，它提供了一个部署云的操作平台或工具集，其宗旨在于：帮助组织运行为虚拟计算或存储服务的云，为公有云、私有云，也为大云、小云提供可扩展的、灵活的云计算。<br>OpenStack开源项目由社区维护，主要包括以下组件。 OpenStack提供了一个操作平台，或工具包，用于编排云。<br><img src="https://github.com/lvyunze/image/blob/master/openstack%E6%A2%B3%E7%90%86/openstack%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6.png?raw=true" alt></p><p><strong>Horizon-UI模块</strong><br>主要服务为openstack用户提供UI服务，也就是负责用户在管理控制台上的所有操作转化为后台API的调用。<br>用户：云管理员【负责整个云平台的运营，资源管理和分配】，普通云用户【在配额范围内，自由操作，使用资源】云管理员界面：</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机</title>
      <link href="/2019/09/08/zhi-chi-xiang-liang-ji/"/>
      <url>/2019/09/08/zhi-chi-xiang-liang-ji/</url>
      
        <content type="html"><![CDATA[<p>支持向量机是什么？</p><p>支持向量机是一种<strong>有监督的机器学习算法</strong>，可以用于<strong>分类或回归</strong>问题。它使用一种称为核技巧的技术来转换数据，然后根据这些转换在可能的输出之间找到一个最佳边界。<strong>简单地说，它做一些非常复杂的数据转换，然后根据定义的标签或输出来划分数据</strong>。</p><p>假设你是一个农民，你有一个问题 - 你需要设置一个围栏，以保护你的奶牛免受狼的攻击。 但是你在哪里建造篱笆？ 好吧，如果你是一个真正的数据驱动农民，你可以做的一件事就是建立一个基于你牧场中奶牛和狼的位置的分类器。 通过几种不同类型的分类器，我们看到SVM在从狼群中分离你的奶牛方面做得很好。 我认为这些图也很好地说明了使用非线性分类器的好处。 您可以看到逻辑和决策树模型都只使用直线。<br><img src="https://github.com/lvyunze/image/raw/master/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 有监督的机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化</title>
      <link href="/2019/08/30/xu-ni-hua/"/>
      <url>/2019/08/30/xu-ni-hua/</url>
      
        <content type="html"><![CDATA[<p><strong>虚拟化</strong><br>虚拟化是云计算的基础。简单的说，虚拟化使得在一台物理的服务器上可以跑多台虚拟机，虚拟机共享物理机的 CPU、内存、IO 硬件资源，但逻辑上虚拟机之间是相互隔离的。</p><p>物理机我们一般称为宿主机（Host），宿主机上面的虚拟机称为客户机（Guest）。那么 Host 是如何将自己的硬件资源虚拟化，并提供给 Guest 使用的呢？</p><p>这个主要是通过一个叫做 Hypervisor 的程序实现的。根据 Hypervisor 的实现方式和所处的位置，虚拟化又分为两种：1型虚拟化和2型虚拟化。</p><p><strong>1型虚拟化</strong><br>Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。Hypervisor 实现方式一般是一个特殊定制的 Linux 系统。Xen 和 VMWare 的 ESXi 都属于这个类型</p><p><strong>2型虚拟化</strong><br>物理机上首先安装常规的操作系统，比如 Redhat、Ubuntu 和 Windows。Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。KVM、VirtualBox 和 VMWare Workstation 都属于这个类型。</p><p>理论上讲：<br>1型虚拟化一般对硬件虚拟化功能进行了特别优化，性能上比2型要高；<br>2型虚拟化因为基于普通的操作系统，会比较灵活，比如支持虚拟机嵌套。嵌套意味着可以在KVM虚拟机中再运行KVM。</p><p><strong>KVM</strong><br>下面重点介绍KVM这种2型虚拟化技术。<br>基本概念<br>在 x86 平台上最热门运用最广泛的虚拟化方案莫过于 KVM 了。OpenStack 对 KVM 支持得也最好，我们的教程也理所当然选择 KVM 作为 实验环境的Hypervisor。</p><p>KVM 全称是 Kernel-Based Virtual Machine。也就是说 KVM 是基于 Linux 内核实现的。KVM有一个内核模块叫 kvm.ko，只用于管理虚拟 CPU 和内存。<br>那 IO 的虚拟化，比如存储和网络设备由谁实现呢？</p><p>这个就交给 Linux 内核和Qemu来实现。说白了，作为一个 Hypervisor，KVM 本身只关注虚拟机调度和内存管理这两个方面。IO 外设的任务交给 Linux 内核和 Qemu。</p><p><strong>Libvirt</strong><br>大家在网上看 KVM 相关文章的时候肯定经常会看到 Libvirt 这个东西。Libvirt 是啥？</p><p>简单说就是 KVM 的管理工具。<br>其实，Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等。OpenStack 底层也使用 Libvirt，所以很有必要学习一下。</p><p>Libvirt 包含 3 个东西：后台 daemon 程序 libvirtd、API 库和命令行工具 virsh<br>libvirtd是服务程序，接收和处理 API 请求；<br>API 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，这是个图形化的 KVM 管理工具，后面我们也会介绍；<br>virsh 是我们经常要用的 KVM 命令行工具，后面会有使用的示例。<br>作为 KVM 和 OpenStack 的实施人员，virsh 和 virt-manager 是一定要会用的。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的重要概念</title>
      <link href="/2019/08/25/k8s-de-chong-yao-gai-nian/"/>
      <url>/2019/08/25/k8s-de-chong-yao-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>在实践之前，必须先学习 Kubernetes 的几个重要概念，它们是组成 Kubernetes 集群的基石。</p><p>*<em>Cluster *</em><br>Cluster 是计算、存储和网络资源的集合，Kubernetes 利用这些资源运行各种基于容器的应用。</p><p><strong>Master</strong><br>Master 是 Cluster 的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master 运行 Linux 操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个 Master。</p><p><strong>Node</strong><br>Node 的职责是运行容器应用。Node 由 Master 管理，Node 负责监控并汇报容器的状态，并根据 Master 的要求管理容器的生命周期。Node 运行在 Linux 操作系统，可以是物理机或者是虚拟机。</p><p>在前面交互式教程中我们创建的 Cluster 只有一个主机 host01，<br>它既是 Master 也是 Node<br><img src="https://github.com/lvyunze/image/raw/master/k8s%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/1.bmp" alt><br><strong>Pod</strong><br>Pod 是 Kubernetes 的最小工作单元。每个 Pod 包含一个或多个容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。</p><p>Kubernetes 引入 Pod 主要基于下面两个目的：</p><p>1、可管理性。<br>有些容器天生就是需要紧密联系，一起工作。Pod 提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes 以 Pod 为最小单位进行调度、扩展、共享资源、管理生命周期。</p><p>2、通信和资源共享。<br>Pod 中的所有容器使用同一个网络 namespace，即相同的 IP 地址和 Port 空间。它们可以直接用 localhost 通信。同样的，这些容器可以共享存储，当 Kubernetes 挂载 volume 到 Pod，本质上是将 volume 挂载到 Pod 中的每一个容器。</p><p>Pods 有两种使用方式：</p><p>1、运行单一容器。<br>one-container-per-Pod 是 Kubernetes 最常见的模型，这种情况下，只是将单个容器简单封装成 Pod。即便是只有一个容器，Kubernetes 管理的也是 Pod 而不是直接管理容器。</p><p>2、运行多个容器。<br>但问题在于：哪些容器应该放到一个 Pod 中？<br>答案是：这些容器联系必须 非常紧密，而且需要 直接共享资源。<br>举个例子。</p><p>下面这个 Pod 包含两个容器：一个 File Puller，一个是 Web Server。<br><img src="https://github.com/lvyunze/image/raw/master/k8s%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/2.bmp" alt><br>File Puller 会定期从外部的 Content Manager 中拉取最新的文件，将其存放在共享的 volume 中。Web Server 从 volume 读取文件，响应 Consumer 的请求。<br>这两个容器是紧密协作的，它们一起为 Consumer 提供最新的数据；同时它们也通过 volume 共享数据。所以放到一个 Pod 是合适的。</p><p>再来看一个反例：是否需要将 Tomcat 和 MySQL 放到一个 Pod 中？</p><p>Tomcat 从 MySQL 读取数据，它们之间需要协作，但还不至于需要放到一个 Pod 中一起部署，一起启动，一起停止。同时它们是之间通过 JDBC 交换数据，并不是直接共享存储，所以放到各自的 Pod 中更合适。</p><p><strong>Controller</strong><br>Kubernetes 通常不会直接创建 Pod，而是通过 Controller 来管理 Pod 的。Controller 中定义了 Pod 的部署特性，比如有几个副本，在什么样的 Node 上运行等。为了满足不同的业务场景，Kubernetes 提供了多种 Controller，包括 Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job 等，我们逐一讨论。</p><p><strong>Deployment</strong><br>是最常用的 Controller，比如前面在线教程中就是通过创建 Deployment 来部署应用的。Deployment 可以管理 Pod 的多个副本，并确保 Pod 按照期望的状态运行。</p><p><strong>ReplicaSet</strong><br>实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本，我们通常不需要直接使用 ReplicaSet。</p><p><strong>DaemonSet</strong><br>用于每个 Node 最多只运行一个 Pod 副本的场景。正如其名称所揭示的，DaemonSet 通常用于运行 daemon。</p><p><strong>StatefulSet</strong><br>能够保证 Pod 的每个副本在整个生命周期中名称是不变的。而其他 Controller 不提供这个功能，当某个 Pod 发生故障需要删除并重新启动时，Pod 的名称会发生变化。同时 StatefuleSet 会保证副本按照固定的顺序启动、更新或者删除。</p><p><strong>Job</strong><br>用于运行结束就删除的应用。而其他 Controller 中的 Pod 通常是长期持续运行。</p><p><strong>Service</strong><br>Deployment 可以部署多个副本，每个 Pod 都有自己的 IP，外界如何访问这些副本呢？<br>通过 Pod 的 IP 吗？<br>要知道 Pod 很可能会被频繁地销毁和重启，它们的 IP 会发生变化，用 IP 来访问不太现实。</p><p>答案是 Service。<br>Kubernetes Service 定义了外界访问一组特定 Pod 的方式。Service 有自己的 IP 和端口，Service 为 Pod 提供了负载均衡。</p><p>Kubernetes 运行容器（Pod）与访问容器（Pod）这两项任务分别由 Controller 和 Service 执行。</p><p><strong>Namespace</strong><br>如果有多个用户或项目组使用同一个 Kubernetes Cluster，如何将他们创建的 Controller、Pod 等资源分开呢？</p><p>答案就是 Namespace。<br>Namespace 可以将一个物理的 Cluster 逻辑上划分成多个虚拟 Cluster，每个 Cluster 就是一个 Namespace。不同 Namespace 里的资源是完全隔离的。</p><p>Kubernetes 默认创建了两个 Namespace。<br><img src="https://github.com/lvyunze/image/raw/master/k8s%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/3.bmp" alt><br>default – 创建资源时如果不指定，将被放到这个 Namespace 中。</p><p>kube-system – Kubernetes 自己创建的系统资源将放到这个 Namespace 中。</p><p>熟悉了 k8s 的这些重要概念，下节开始，我们将搭建自己的 Kubernetes 集群。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s的重要概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到小镇的法官</title>
      <link href="/2019/08/25/zhao-dao-xiao-zhen-de-fa-guan/"/>
      <url>/2019/08/25/zhao-dao-xiao-zhen-de-fa-guan/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。</p><p>如果小镇的法官真的存在，那么：</p><p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足属性 1 和属性 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。</p><p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。</p><blockquote><p>示例 1：<br>输入：N = 2, trust = [[1,2]]<br>输出：2</p></blockquote><blockquote><p>示例 2：<br>输入：N = 3, trust = [[1,3],[2,3]]<br>输出：3</p></blockquote><blockquote><p>示例 3：<br>输入：N = 3, trust = [[1,3],[2,3],[3,1]]<br>输出：-1</p></blockquote><blockquote><p>示例 4：<br>输入：N = 3, trust = [[1,2],[2,3]]<br>输出：-1</p></blockquote><blockquote><p>示例 5：<br>输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]<br>输出：3</p></blockquote><p>提示：</p><p>1 &lt;= N &lt;= 1000<br>trust.length &lt;= 10000<br>trust[i] 是完全不同的<br>trust[i][0] != trust[i][1]<br>1 &lt;= trust[i][0], trust[i][1] &lt;= N</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>本题主要使用有向图的思想解题目</p><p>简单来说，就是已知若干人相信的人，要找一个人，他被所有人相信，但是不相信所有人。<br>如果把a相信b看成是一条a指向b边，那么题意转化在一个有向图里面，为要找一个点，它被其他所以的点指向，但是不指向所有的点。<br>按照图论说法，有向图中，一个点有两种度，一种是入度，一种是出度。入度就是被其他边指向的次数，出度就是指向其他点的次数。<br>比如：有3条边， a -&gt; b， a -&gt; c， b -&gt; c<br>那么：<br>a的出度为2， 入度为0<br>b的出度为1， 入度为1<br>c的出度为0， 入度为2<br>那么按照刚刚理解，就是找到一个点的出度为0， 入度为 N-1 的编号即为解， 否则返回-1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>  class Solution:    def findJudge(self, N: int, trust: List[List[int]]) -&gt; int:        if N==1:            return 1        d=collections.defaultdict(int)      #统计入度数        for i,j in trust:           # 用一个列表res记录每个人被别人信任的个数，如果某个人信任别人，则在信任个数上减1，           # 如果别人信任自己，就信任个数上加1            d[i]-=1     #存在出度就减成无效数据            d[j]+=1        for i in d:            if d[i]==N-1:                return i        return -1</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票的最佳时机III</title>
      <link href="/2019/08/24/mai-mai-gu-piao-de-zui-jia-shi-ji-iii/"/>
      <url>/2019/08/24/mai-mai-gu-piao-de-zui-jia-shi-ji-iii/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><blockquote><p>示例 1:<br>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><blockquote><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p></blockquote><blockquote><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>主要抓住这里要求求不超过两个的最大收益，可以使用动态规划的方法，先求出两个收益值，后面再不断比较收益值，<br>要是比原来的大就取最大的两个，要是不必原来大就取原来的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution:    def maxProfit(self, prices):        &quot;&quot;&quot;        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        if not prices:            return 0        pay_before,profit_before,pay_after,profit_after = -prices[0],0,-prices[0],0        for i in range(len(prices)):            pay_before = max(pay_before,-prices[i])            profit_before = max(profit_before,pay_before+prices[i])            pay_after = max(pay_after,profit_before-prices[i])            profit_after = max(profit_after,pay_after+prices[i])        return profit_after</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票的最佳时机</title>
      <link href="/2019/08/22/mai-mai-gu-piao-de-zui-jia-shi-ji/"/>
      <url>/2019/08/22/mai-mai-gu-piao-de-zui-jia-shi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><blockquote><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></blockquote><blockquote><p>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>第一就是取数，在数组种找到较小的数，计算找到的最小值在最后一个，后面还是会取最大的差值<br>然后第二就是计算差值，找到最大的差值即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution(object):    def maxProfit(self, prices):        &quot;&quot;&quot;        :type prices: List[int]        :rtype: int        &quot;&quot;&quot;        if len(prices)&lt;=1:            return 0        # 取第一个数        min_p = prices[0]        # 第一初始最大值为0        Max = 0        for i in range(len(prices)):            # 遍历到较小值            min_p = min(min_p,prices[i])            # 求最大差值，这样就算是上面的min_p的最小值是最后一个，Max也是会取最大差值            Max = max(Max,prices[i] - min_p)        return Max</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小路径和</title>
      <link href="/2019/08/22/zui-xiao-lu-jing-he/"/>
      <url>/2019/08/22/zui-xiao-lu-jing-he/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><blockquote><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>最短路径和实现<br>看懂下面两个即可<br>第二个表格由第一个表格推出<br>分为四种情况<br>第一种：有左有上的（左和上的最小值+原来所在位置的值）<br>第二种：只有左的（左+原来所在位置的值）<br>第三种：只有上的（上+原来所在位置的值）<br>第四种：没有上没有左的（原来所在位置的值）</p><p>这张图对应的四种情况分别要设置4种求法<br><img src="https://github.com/lvyunze/image/raw/master/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/1.png" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution(object):    def minPathSum(self, grid):        &quot;&quot;&quot;        :type grid: List[List[int]]        :rtype: int        &quot;&quot;&quot;                #获取行        m = len(grid)        #获取列        n = len(grid[0])        # 建立多少维数组,m行n列        res = [[0]*n]*m        # 循环行        for i in range(m):            # 循环列            for j in range(n):                if 0 &lt;= i-1 &lt; m and 0 &lt;= j-1 &lt; n:                    res[i][j] = min(res[i][j-1],res[i-1][j])+grid[i][j]                #第一行中,第一个除外                elif 0 &lt;= i-1 &lt; m:                    res[i][j] = res[i-1][j] + grid[i][j]                #第一列中，第一个除外                #                 elif 0 &lt;= j-1 &lt; n:                    res[i][j] = res[i][j-1] + grid[i][j]                 else:                    res[i][j] = grid[i][j]        return res[m-1][n-1]</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络</title>
      <link href="/2019/08/19/docker-wang-luo/"/>
      <url>/2019/08/19/docker-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="none和host网络的适用场景"><a href="#none和host网络的适用场景" class="headerlink" title="none和host网络的适用场景"></a>none和host网络的适用场景</h3><p>我们会首先学习 Docker 提供的几种原生网络，以及如何创建自定义网络。然后探讨容器之间如何通信，以及容器与外界如何交互。</p><p>Docker 网络从覆盖范围可分为单个 host 上的容器网络和跨多个 host 的网络，现在重点讨论前一种。对于更为复杂的多 host 容器网络，后面会单独讨论。</p><p>Docker 安装时会自动在 host 上创建三个网络，我们可用 <strong>docker network ls</strong> 命令查看：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/1.bmp" alt><br>下面我们分别讨论它们。</p><p><strong>none 网络</strong></p><p>故名思议，none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/2.bmp" alt><br>我们不禁会问，这样一个封闭的网络有什么用呢？</p><p>其实还真有应用场景。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。</p><p>比如某个容器的唯一用途是生成随机密码，就可以放到 none 网络中避免密码被窃取。</p><p>当然大部分容器是需要网络的，我们接着看 host 网络。</p><p><strong>host 网络</strong><br>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与 host 完全一样。可以通过 –network=host 指定使用 host 网络。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/3.bmp" alt><br>在容器中可以看到 host 的所有网卡，并且连 hostname 也是 host 的。host 网络的使用场景又是什么呢？</p><p>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，Docker host 上已经使用的端口就不能再用了。</p><p>Docker host 的另一个用途是让容器可以直接配置 host 网路。比如某些跨 host 的网络解决方案，其本身也是以容器方式运行的，这些方案需要对网络进行配置，比如管理 iptables</p><p><strong>学容器必须懂 bridge 网络</strong><br>应用最广泛也是默认的 bridge 网络<br>Docker 安装时会创建一个 命名为 <strong>docker0</strong> 的 <strong>linux bridge</strong>。如果不指定<strong>–network</strong>，创建的容器默认都会挂到 docker0 上。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/4.bmp" alt><br>当前 docker0 上没有任何其他网络设备，我们创建一个容器看看有什么变化。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/5.bmp" alt><br>一个新的网络接口 veth28c57df 被挂到了 docker0 上，veth28c57df就是新创建容器的虚拟网卡。</p><p>下面看一下容器的网络配置。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/6.bmp" alt><br>容器有一个网卡 eth0@if34。大家可能会问了，为什么不是veth28c57df 呢？</p><p>实际上 eth0@if34 和 veth28c57df 是一对 veth pair。veth pair 是一种成对出现的特殊网络设备，可以把它们想象成由一根虚拟网线连接起来的一对网卡，网卡的一头（eth0@if34）在容器中，另一头（veth28c57df）挂在网桥 docker0 上，其效果就是将 eth0@if34 也挂在了 docker0 上。</p><p>我们还看到 eth0@if34 已经配置了 IP 172.17.0.2，为什么是这个网段呢？让我们通过 docker network inspect bridge 看一下 bridge 网络的配置信息:<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/7.bmp" alt><br>原来 bridge 网络配置的 subnet 就是 172.17.0.0/16，并且网关是 172.17.0.1。这个网关在哪儿呢？大概你已经猜出来了，就是 docker0。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/8.bmp" alt><br>当前容器网络拓扑结构如图所示：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/9.bmp" alt><br>容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p><p>除了 none, host, bridge 这三个自动创建的网络，用户也可以根据业务需要创建 user-defined 网络</p><h3 id="如何自定义容器网络？"><a href="#如何自定义容器网络？" class="headerlink" title="如何自定义容器网络？"></a>如何自定义容器网络？</h3><p>除了 none, host, bridge 这三个自动创建的网络，用户也可以根据业务需要创建 user-defined 网络。</p><p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络，我们后面有章节单独讨论。</p><p>我们可通过 bridge 驱动创建类似前面默认的 bridge 网络，例如：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/10.bmp" alt><br>查看一下当前 host 的网络结构变化：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/11.bmp" alt><br>新增了一个网桥 br-eaed97dc9a77，这里 eaed97dc9a77 正好新建 bridge 网络 my_net 的短 id。执行 docker network inspect 查看一下 my_net 的配置信息：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/12.bmp" alt><br>这里 172.18.0.0/16 是 Docker 自动分配的 IP 网段。</p><p>我们可以自己指定 IP 网段吗？<br>答案是：可以。</p><p>只需在创建网段时指定 –subnet 和 –gateway 参数：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/13.bmp" alt><br>这里我们创建了新的 bridge 网络 my_net2，网段为 172.22.16.0/24，网关为 172.22.16.1。与前面一样，网关在 my_net2 对应的网桥 br-5d863e9f78b6 上：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/14.bmp" alt><br>容器要使用新的网络，需要在启动时通过 –network 指定：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/15.bmp" alt><br>容器分配到的 IP 为 172.22.16.2。</p><p>到目前为止，容器的 IP 都是 docker 自动从 subnet 中分配，我们能否指定一个静态 IP 呢？</p><p>答案是：可以，通过–ip指定。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/16.bmp" alt><br>注：只有使用 –subnet 创建的网络才能指定静态 IP。</p><p>my_net 创建时没有指定 –subnet，如果指定静态 IP 报错如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/17.bmp" alt></p><h3 id="理解容器之间的连通性"><a href="#理解容器之间的连通性" class="headerlink" title="理解容器之间的连通性"></a>理解容器之间的连通性</h3><p>当前 docker host 的网络拓扑结构如下图所示，今天我们将讨论这几个容器之间的连通性。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/18.bmp" alt><br>两个 busybox 容器都挂在 my_net2 上，应该能够互通，我们验证一下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/19.bmp" alt><br>可见同一网络中的容器、网关之间都是可以通信的。</p><p>my_net2 与默认 bridge 网络能通信吗？</p><p>从拓扑图可知，两个网络属于不同的网桥，应该不能通信，我们通过实验验证一下，让 busybox 容器 ping httpd 容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/20.bmp" alt><br>确实 ping 不通，符合预期。</p><p>“等等！不同的网络如果加上路由应该就可以通信了吧？”我已经听到有读者在建议了。</p><p>这是一个非常非常好的想法。</p><p>确实，如果 host 上对每个网络的都有一条路由，同时操作系统上打开了 ip forwarding，host 就成了一个路由器，挂接在不同网桥上的网络就能够相互通信。下面我们来看看 docker host 满不满足这些条件呢？</p><p>ip r 查看 host 上的路由表：</p><pre><code># ip r......172.17.0.0/16 dev docker0  proto kernel  scope link  src 172.17.0.1172.22.16.0/24 dev br-5d863e9f78b6  proto kernel  scope link  src 172.22.16.1......</code></pre><p>172.17.0.0/16 和 172.22.16.0/24 两个网络的路由都定义好了。再看看 ip forwarding：</p><pre><code># sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>ip forwarding 也已经启用了。</p><p>条件都满足，为什么不能通行呢？</p><p>我们还得看看 iptables：</p><pre><code># iptables-save......-A DOCKER-ISOLATION -i br-5d863e9f78b6 -o docker0 -j DROP-A DOCKER-ISOLATION -i docker0 -o br-5d863e9f78b6 -j DROP......</code></pre><p>原因就在这里了：iptables DROP 掉了网桥 docker0 与 br-5d863e9f78b6 之间双向的流量。</p><p>从规则的命名 DOCKER-ISOLATION 可知 docker 在设计上就是要隔离不同的 netwrok。</p><p>那么接下来的问题是：怎样才能让 busybox 与 httpd 通信呢？</p><p>答案是：为 httpd 容器添加一块 net_my2 的网卡。这个可以通过docker network connect 命令实现<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/21.bmp" alt><br>我们在 httpd 容器中查看一下网络配置：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/22.bmp" alt><br>容器中增加了一个网卡 eth1，分配了 my_net2 的 IP 172.22.16.3。现在 busybox 应该能够访问 httpd 了，验证一下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/23.bmp" alt><br>busybox 能够 ping 到 httpd，并且可以访问 httpd 的 web 服务。当前网络结构如图所示：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/24.bmp" alt></p><h3 id="容器间通信的三种方式"><a href="#容器间通信的三种方式" class="headerlink" title="容器间通信的三种方式"></a>容器间通信的三种方式</h3><p>容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信</p><p><strong>IP 通信</strong><br>从上一节的例子可以得出这样一个结论：两个容器要能通信，必须要有属于同一个网络的网卡。</p><p>满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 –network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。可参考上一节 httpd 和 busybox 的例子，这里不再赘述。</p><p><strong>Docker DNS Server</strong><br>通过 IP 访问容器虽然满足了通信的需求，但还是不够灵活。因为我们在部署应用之前可能无法确定 IP，部署之后再指定要访问的 IP 会比较麻烦。对于这个问题，可以通过 docker 自带的 DNS 服务解决。</p><p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 –name 为容器命名就可以了。</p><p>下面启动两个容器 bbox1 和 bbox2</p><pre><code>docker run -it --network=my_net2 --name=bbox1 busyboxdocker run -it --network=my_net2 --name=bbox2 busybox</code></pre><p><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/25.bmp" alt><br>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的。下面验证一下：</p><p>创建 bbox3 和 bbox4，均连接到 bridge 网络。</p><pre><code>docker run -it --name=bbox3 busyboxdocker run -it --name=bbox4 busybox</code></pre><p>bbox4 无法 ping 到 bbox3。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/26.bmp" alt></p><p><strong>joined 容器</strong><br>joined 容器是另一种实现容器间通信的方式。</p><p>joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。请看下面的例子：</p><p>先创建一个 httpd 容器，名字为 web1。</p><blockquote><p>docker run -d -it –name=web1 httpd</p></blockquote><p>然后创建 busybox 容器并通过 –network=container:web1 指定 jointed 容器为 web1：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/27.bmp" alt><br>请注意 busybox 容器中的网络配置信息，下面我们查看一下 web1 的网络：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/28.bmp" alt><br>看！busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/29.jpg" alt><br>joined 容器非常适合以下场景：</p><p>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</p><p>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</p><p><strong>容器如何访问外部世界？</strong><br>前面我们已经解决了容器间通信的问题，接下来讨论容器如何与外部世界通信。这里涉及两个方向：<br>1、容器访问外部世界<br>2、外部世界访问容器</p><p><strong>容器访问外部世界</strong><br>在我们当前的实验环境下，docker host 是可以访问外网的。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/30.bmp" alt><br>我们看一下容器是否也能访问外网呢？<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/31.bmp" alt><br>可见，容器默认就能访问外网。</p><p>请注意：这里外网指的是容器网络以外的网络环境，并非特指 internet。</p><p>现象很简单，但更重要的：我们应该理解现象下的本质。</p><p>在上面的例子中，busybox 位于 docker0 这个私有 bridge 网络中（172.17.0.0/16），当 busybox 从容器向外 ping 时，数据包是怎样到达 bing.com 的呢？</p><p>这里的关键就是 NAT。我们查看一下 docker host 上的 iptables 规则：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/32.bmp" alt><br>在 NAT 表中，有这么一条规则：</p><p>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</p><p>其含义是：如果网桥 docker0 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。而 MASQUERADE 的处理方式是将包的源地址替换成 host 的地址发送出去，即做了一次网络地址转换（NAT）。</p><p>下面我们通过 tcpdump 查看地址是如何转换的。先查看 docker host 的路由表：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/33.bmp" alt><br>默认路由通过 enp0s3 发出去，所以我们要同时监控 enp0s3 和 docker0 上的 icmp（ping）数据包。</p><p>当 busybox ping bing.com 时，tcpdump 输出如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/34.bmp" alt><br>docker0 收到 busybox 的 ping 包，源地址为容器 IP 172.17.0.2，这没问题，交给 MASQUERADE 处理。这时，在 enp0s3 上我们看到了变化：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/35.bmp" alt></p><p><strong>ping 包的源地址变成了 enp0s3 的 IP 10.0.2.15</strong><br>这就是 iptable NAT 规则处理的结果，从而保证数据包能够到达外网。下面用一张图来说明这个过程：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/36.bmp" alt><br>1、busybox 发送 ping 包：172.17.0.2 &gt; <a href="http://www.bing.com。" target="_blank" rel="noopener">www.bing.com。</a></p><p>2、docker0 收到包，发现是发送到外网的，交给 NAT 处理。</p><p>3、NAT 将源地址换成 enp0s3 的 IP：10.0.2.15 &gt; <a href="http://www.bing.com。" target="_blank" rel="noopener">www.bing.com。</a></p><p>4、ping 包从 enp0s3 发送出去，到达 <a href="http://www.bing.com。" target="_blank" rel="noopener">www.bing.com。</a></p><p>通过 NAT，docker 实现了容器对外网的访问。</p><h3 id="外部世界如何访问容器？"><a href="#外部世界如何访问容器？" class="headerlink" title="外部世界如何访问容器？"></a>外部世界如何访问容器？</h3><p>外部网络如何访问到容器？</p><p>答案是：<strong>端口映射</strong>。</p><p>docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/37.bmp" alt><br>容器启动后，可通过 docker ps 或者 docker port 查看到 host 映射的端口。在上面的例子中，httpd 容器的 80 端口被映射到 host 32773 上，这样就可以通过 <host ip>:&lt;32773&gt; 访问容器的 web 服务了。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/38.bmp" alt><br>除了映射动态端口，也可在 -p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/39.bmp" alt><br>每一个映射的端口，host 都会启动一个 docker-proxy 进程来处理访问容器的流量：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/40.bmp" alt><br>以 0.0.0.0:32773-&gt;80/tcp 为例分析整个过程：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E7%BD%91%E7%BB%9C/41.bmp" alt><br>1、docker-proxy 监听 host 的 32773 端口。</host></p><p>2、当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</p><p>3、httpd 容器响应请求并返回结果。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2019/08/19/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2019/08/19/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码解决"><a href="#代码解决" class="headerlink" title="代码解决"></a>代码解决</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四数之和</title>
      <link href="/2019/08/18/si-shu-zhi-he/"/>
      <url>/2019/08/18/si-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>1、判断题目类型：数组类型<br>2、解决关键：数组指针（左右指针）<br>3、考虑边界值：<br>第一种情况：左指针+右指针&lt;目标点<br>第二种情况：左指针+右指针&gt;目标点<br>第三种情况：重复<br>左指针-1和左指针相等<br>右指针和右指针+1相等<br>这个和求三数之和相比需要注意的是这个传入的参数是两个，有一个nums和target,target不一定是0，而三数之和传入的参数只有nums一个，求总和为0</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution():    def fourSum(self, nums,target):        res = []        nums.sort()        for i in range(0, len(nums) - 3):            if i &gt; 0 and nums[i] == nums[i-1]:                continue            for j in range(i+1, len(nums) - 2):                if j &gt;i+1 and nums[j] == nums[j - 1]:                    continue                start, end = j + 1, len(nums) - 1                                               while start &lt; end:                    all = nums[start]+nums[end]+nums[i]+nums[j]                    # 第一种情况                    if all &gt; target:                        end -= 1                    # 第二种情况                    elif all &lt; target :                        start += 1                    else:                        res.append((nums[i], nums[j], nums[start], nums[end]))                        end -= 1                        start += 1                        # 第三种情况                        while start &lt; end and nums[end] == nums[end + 1]:                            end -= 1                        while start &lt; end and nums[start] == nums[start - 1]:                            start += 1        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器</title>
      <link href="/2019/08/16/docker-rong-qi/"/>
      <url>/2019/08/16/docker-rong-qi/</url>
      
        <content type="html"><![CDATA[<p>注：文章来源于作者：CloudMan<br>书籍：《每天五分钟玩转Docker容器技术》</p><h3 id="如何运行容器？"><a href="#如何运行容器？" class="headerlink" title="如何运行容器？"></a>如何运行容器？</h3><p><strong>运行容器</strong><br>docker run 是启动容器的方法。在讨论 Dockerfile 时我们已经学习到，可用三种方式指定容器启动时执行的命令：</p><p>1、CMD 指令。<br>2、ENDPOINT 指令。<br>3、在 docker run 命令行中指定。</p><p>例如下面的例子：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/1.bmp" alt><br>容器启动时执行 <strong>pwd</strong>，返回的 <strong>/</strong> 是容器中的当前目录。 执行 <strong>docker ps</strong> 或 <strong>docker container ls</strong> 可以查看 <strong>Docker host</strong> 中当前运行的容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/2.bmp" alt><br>咦，怎么没有容器？用 <strong>docker ps -a</strong> 或 <strong>docker container ls -a</strong> 看看。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/3.bmp" alt><br>-a 会显示所有状态的容器，可以看到，之前的容器已经退出了，状态为Exited。</p><p>这种“一闪而过”的容器通常不是我们想要的结果，我们希望容器能够保持 runing 状态，这样才能被我们使用。</p><p><strong>让容器长期运行</strong><br>如何让容器保存运行呢？</p><p>因为容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。</p><p>理解了这个原理，我们就可以通过执行一个长期运行的命令来保持容器的运行状态。例如执行下面的命令：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/4.bmp" alt><br><strong>while</strong> 语句让 bash 不会退出。我们可以打开另一个终端查看容器的状态：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/5.bmp" alt><br>可见容器仍处于运行状态。不过这种方法有个缺点：它占用了一个终端。</p><p>我们可以加上参数 -d 以后台方式启动容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/6.bmp" alt><br>容器启动后回到了 docker host 的终端。这里看到 docker 返回了一串字符，这是容器的 ID。通过 docker ps 查看容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/7.bmp" alt><br>现在我们有了两个正在运行的容器。这里注意一下容器的 CONTAINER ID和 NAMES 这两个字段。<br><strong>CONTAINER ID</strong> 是容器的 “短ID”，前面启动容器时返回的是 “长ID”。短ID是长ID的前12个字符。<br><strong>NAMES</strong> 字段显示容器的名字，在启动容器时可以通过 <strong>–name</strong> 参数显示地为容器命名，如果不指定，docker 会自动为容器分配名字。<br>对于容器的后续操作，我们需要通过 “长ID”、“短ID” 或者 “名称” 来指定要操作的容器。比如下面停止一个容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/8.bmp" alt><br>这里我们就是通过 “短ID” 指定了要停止的容器。</p><p>通过 <strong>while</strong> 启动的容器虽然能够保持运行，但实际上没有干什么有意义的事情。容器常见的用途是运行后台服务，例如前面我们已经看到的 http server：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/9.bmp" alt><br>这一次我们用 <strong>–name</strong> 指定了容器的名字。 我们还看到容器运行的命令是<strong>httpd-foreground</strong>，通过 <strong>docker history</strong> 可知这个命令是通过 CMD 指定的。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/10.bmp" alt></p><h3 id="两种进入容器的方法"><a href="#两种进入容器的方法" class="headerlink" title="两种进入容器的方法"></a>两种进入容器的方法</h3><p>我们经常需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。有两种方法进入容器：attach 和 exec。</p><p><strong>docker attach</strong><br>通过 <strong>docker attach</strong> 可以 attach 到容器启动命令的终端，例如：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/11.bmp" alt><br>这次我们通过 “长ID” attach 到了容器的启动命令终端，之后看到的是echo 每隔一秒打印的信息。</p><p>注：可通过 Ctrl+p 然后 Ctrl+q 组合键退出 attach 终端。</p><p><strong>docker exec</strong><br>通过 <strong>docker exec</strong> 进入相同的容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/12.bmp" alt><br>说明如下：</p><p>① -it 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端。</p><p>② 进入到容器中，容器的 hostname 就是其 “短ID”。</p><p>③ 可以像在普通 Linux 中一样执行命令。ps -elf 显示了容器启动进程while 以及当前的 bash 进程。</p><p>④ 执行 exit 退出容器，回到 docker host。</p><p>docker exec -it <container> bash|sh 是执行 exec 最常用的方式。</container></p><p><strong>attach VS exec</strong><br>attach 与 exec 主要区别如下:</p><p>1、attach 直接进入容器 启动命令 的终端，不会启动新的进程。</p><p>2、exec 则是在容器中打开新的终端，并且可以启动新的进程。</p><p>3、如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。</p><p>当然，如果只是为了查看启动命令的输出，可以使用 docker logs 命令：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/13.bmp" alt><br>-f 的作用与 tail -f 类似，能够持续打印输出。</p><h3 id="运行容器的最佳实践"><a href="#运行容器的最佳实践" class="headerlink" title="运行容器的最佳实践"></a>运行容器的最佳实践</h3><ol><li><p>服务类容器以 <strong>daemon</strong> 的形式运行，对外提供服务。比如 web server，数据库等。通过 <strong>-d</strong> 以后台方式启动这类容器是非常合适的。如果要排查问题，可以通过 <strong>exec -it</strong> 进入容器。</p></li><li><p>工具类容器通常给能我们提供一个临时的工作环境，通常以 <strong>run -it</strong> 方式运行，比如：</p></li></ol><p>运行 busybox，<strong>run -it</strong> 的作用是在容器启动后就直接进入。我们这里通过 wget 验证了在容器中访问 internet 的能力。执行 exit 退出终端，同时容器停止。</p><p>工具类容器多使用基础镜像，例如 busybox、debian、ubuntu 等。</p><p><strong>容器运行小结</strong><br>容器运行相关的知识点：</p><p>1、当 <strong>CMD</strong> 或 <strong>Entrypoint</strong> 或 <strong>docker run</strong> 命令行指定的命令运行结束时，容器停止。</p><p>2、通过 -d 参数在后台启动容器。</p><p>3、通过 exec -it 可进入容器并执行命令。</p><p>指定容器的三种方法：</p><p>1、短ID。</p><p>2、长ID。</p><p>3、容器名称。 可通过 –name 为容器命名。重命名容器可执行docker rename。</p><p>容器按用途可分为两类：</p><p>1、服务类的容器。</p><p>2、工具类的容器。</p><h3 id="容器常用操作"><a href="#容器常用操作" class="headerlink" title="容器常用操作"></a>容器常用操作</h3><p><strong>stop/start/restart 容器</strong><br>通过 docker stop 可以停止运行的容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/14.bmp" alt><br>容器在 docker host 中实际上是一个进程，docker stop 命令本质上是向该进程发送一个 SIGTERM 信号。如果想快速停止容器，可使用 docker kill 命令，其作用是向容器进程发送 SIGKILL 信号。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/15.bmp" alt><br>对于处于停止状态的容器，可以通过 <strong>docker start</strong> 重新启动。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/16.bmp" alt><br><strong>docker start</strong> 会保留容器的第一次启动时的所有参数。</p><p>docker restart 可以重启容器，其作用就是依次执行 docker stop 和docker start。</p><p>容器可能会因某种错误而停止运行。对于服务类容器，我们通常希望在这种情况下容器能够自动重启。启动容器时设置 <strong>–restart</strong> 就可以达到这个效果。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/17.bmp" alt><br>1<br>–restart=always 意味着无论容器因何种原因退出（包括正常退出），就立即重启。该参数的形式还可以是 –restart=on-failure:3，意思是如果启动进程退出代码非0，则重启容器，最多重启3次。</p><p><strong>pause/unpause 容器</strong></p><p>有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 <strong>docker pause</strong>。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/18.bmp" alt><br>处于暂停状态的容器不会占用 CPU 资源，直到通过 docker unpause 恢复运行。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/19.bmp" alt></p><p><strong>删除容器</strong><br>使用 docker 一段时间后，host 上可能会有大量已经退出了的容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/20.bmp" alt><br>这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 docker rm 删除。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/21.bmp" alt><br><strong>docker rm</strong> 一次可以指定多个容器，如果希望批量删除所有已经退出的容器，可以执行如下命令：</p><blockquote><p>docker rm -v $(docker ps -aq -f status=exited)<br>注：aq = all in quiet<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/22.bmp" alt><br>顺便说一句：docker rm 是删除容器，而 docker rmi 是删除镜像。</p></blockquote><h3 id="一张图搞懂容器所有操作"><a href="#一张图搞懂容器所有操作" class="headerlink" title="一张图搞懂容器所有操作"></a>一张图搞懂容器所有操作</h3><p>前面我们已经讨论了容器的各种操作，对容器的生命周期有了大致的理解，下面这张状态机很好地总结了容器各种状态之间是如何转换的。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/23.bmp" alt><br>如果掌握了前面的知识，要看懂这张图应该不难。不过有两点还是需要补充一下：<br>1、可以先创建容器，稍后再启动。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/24.bmp" alt><br>① docker create 创建的容器处于 Created 状态。</p><p>② docker start 将以后台方式启动容器。 docker run 命令实际上是 docker create 和 docker start 的组合。</p><p>2、只有当容器的启动进程 退出 时，–restart 才生效<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/25.bmp" alt><br>退出包括正常退出或者非正常退出。这里举了两个例子：启动进程正常退出或发生 OOM，此时 docker 会根据 –restart 的策略判断是否需要重启容器。但如果容器是因为执行 docker stop 或docker kill 退出，则不会自动重启。</p><h3 id="限制容器对内存的使用"><a href="#限制容器对内存的使用" class="headerlink" title="限制容器对内存的使用"></a>限制容器对内存的使用</h3><p>一个 docker host 上会运行若干容器，每个容器都需要 CPU、内存和 IO 资源。对于 KVM，VMware 等虚拟化技术，用户可以控制分配多少 CPU、内存资源给每个虚拟机。对于容器，Docker 也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个 host 的性能。</p><p><strong>内存限额</strong><br>与操作系统类似，容器可使用的内存包括两部分：物理内存和 swap。 Docker 通过下面两组参数来控制容器内存的使用量。<br>1、-m 或 –memory：设置内存的使用限额，例如 100M, 2G。</p><p>2、–memory-swap：设置 内存+swap 的使用限额。</p><p>当我们执行如下命令：</p><blockquote><p>docker run -m 200M –memory-swap=300M ubuntu</p></blockquote><p>其含义是允许该容器最多使用 200M 的内存和 100M 的 swap。默认情况下，上面两组参数为 -1，即对容器内存和 swap 的使用没有限制。</p><p>下面我们将使用 progrium/stress 镜像来学习如何为容器分配内存。该镜像可用于对容器执行压力测试。执行如下命令：</p><blockquote><p>docker run -it -m 200M –memory-swap=300M progrium/stress –vm 1 –vm-bytes 280M</p></blockquote><blockquote><p>–vm 1：启动 1 个内存工作线程。</p></blockquote><blockquote><p>–vm-bytes 280M：每个线程分配 280M 内存。</p></blockquote><p>运行结果如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/26.bmp" alt></p><p>因为 280M 在可分配的范围（300M）内，所以工作线程能够正常工作，其过程是：</p><p>1、分配 280M 内存。<br>2、释放 280M 内存。<br>3、再分配 280M 内存。<br>4、再释放 280M 内存。<br>5、一直循环……</p><p>如果让工作线程分配的内存超过 300M，结果如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/27.bmp" alt><br>分配的内存超过限额，stress 线程报错，容器退出。</p><p>如果在启动容器时只指定 <strong>-m</strong> 而不指定 <strong>–memory-swap</strong>，那么 <strong>–memory-swap</strong> 默认为 <strong>-m</strong> 的两倍，比如：</p><blockquote><p>docker run -it -m 200M ubuntu</p></blockquote><p>容器最多使用 200M 物理内存和 200M swap。</p><h3 id="限制容器对CPU的使用"><a href="#限制容器对CPU的使用" class="headerlink" title="限制容器对CPU的使用"></a>限制容器对CPU的使用</h3><p>默认设置下，所有容器可以平等地使用 host CPU 资源并且没有限制。</p><p>Docker 可以通过 <strong>-c</strong> 或 <strong>–cpu-shares</strong> 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。</p><p>与内存限额不同，通过 -c 设置的 cpu share 并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的 cpu share 占所有容器 cpu share 总和的比例。</p><blockquote><p>换句话说：通过 cpu share 可以设置容器使用 CPU 的优先级。</p></blockquote><p>比如在 host 中启动了两个容器：</p><pre><code>docker run --name &quot;container_A&quot; -c 1024 ubuntudocker run --name &quot;container_B&quot; -c 512 ubuntu</code></pre><p>container_A 的 cpu share 1024，是 container_B 的两倍。当两个容器都需要 CPU 资源时，container_A 可以得到的 CPU 是 container_B 的两倍。</p><p>需要特别注意的是，这种按权重分配 CPU 只会发生在 CPU 资源紧张的情况下。如果 container_A 处于空闲状态，这时，为了充分利用 CPU 资源，container_B 也可以分配到全部可用的 CPU。</p><p>下面我们继续用 progrium/stress 做实验。<br>1、启动 container_A，cpu share 为 1024<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/28.bmp" alt><br><strong>–cpu</strong> 用来设置工作线程的数量。因为当前 host 只有 1 颗 CPU，所以一个工作线程就能将 CPU 压满。如果 host 有多颗 CPU，则需要相应增加 –cpu 的数量。</p><p>2、启动 container_B，cpu share 为 512：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/29.bmp" alt></p><p>3、在 host 中执行 top，查看容器对 CPU 的使用情况：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/30.bmp" alt><br>container_A 消耗的 CPU 是 container_B 的两倍。</p><p>4、现在暂停 container_A：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/31.bmp" alt></p><p>5、top 显示 container_B 在 container_A 空闲的情况下能够用满整颗 CPU：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/32.bmp" alt></p><h3 id="限制容器的-Block-IO"><a href="#限制容器的-Block-IO" class="headerlink" title="限制容器的 Block IO"></a>限制容器的 Block IO</h3><p>Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽，下面分别讨论。</p><p>注：目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。</p><p><strong>block IO 权重</strong><br>默认情况下，所有容器能平等地读写磁盘，可以通过设置 –blkio-weight 参数来改变容器 block IO 的优先级。</p><p><strong>–blkio-weight</strong> 与 <strong>–cpu-shares</strong> 类似，设置的是相对权重值，默认为 500。在下面的例子中，container_A 读写磁盘的带宽是 container_B 的两倍。</p><blockquote><p>docker run -it –name container_A –blkio-weight 600 ubuntu<br>docker run -it –name container_B –blkio-weight 300 ubuntu</p></blockquote><p><strong>限制 bps 和 iops</strong><br>bps 是 byte per second，每秒读写的数据量。<br>iops 是 io per second，每秒 IO 的次数。</p><p>可通过以下参数控制容器的 bps 和 iops：</p><p><strong>–device-read-bps</strong>，限制读某个设备的 bps。<br><strong>–device-write-bps</strong>，限制写某个设备的 bps。<br><strong>–device-read-iops</strong>，限制读某个设备的 iops。<br><strong>–device-write-iops</strong>，限制写某个设备的 iops。</p><p>下面这个例子限制容器写 /dev/sda 的速率为 30 MB/s</p><blockquote><p>docker run -it –device-write-bps /dev/sda:30MB ubuntu</p></blockquote><p>我们来看看实验结果：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/33.bmp" alt><br>通过 dd 测试在容器中写磁盘的速度。因为容器的文件系统是在 <strong>host /dev/sda</strong> 上的，在容器中写文件相当于对 <strong>host /dev/sda</strong> 进行写操作。另外，<strong>oflag=direct</strong> 指定用 <strong>direct IO</strong> 方式写文件，这样 <strong>–device-write-bps</strong> 才能生效。</p><p>结果表明，bps 25.6 MB/s 没有超过 30 MB/s 的限速。</p><p>作为对比测试，如果不限速，结果如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/34.bmp" alt></p><h3 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h3><p>cgroup 和 namespace 是最重要的两种技术。cgroup 实现资源限额， namespace 实现资源隔离。</p><p><strong>cgroup</strong><br>cgroup 全称 <strong>Control Group</strong>。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。相信你已经猜到了：前面我们看到的<strong>–cpu-shares</strong>、<strong>-m</strong>、<strong>–device-write-bps</strong> 实际上就是在配置 cgroup。</p><p>cgroup 到底长什么样子呢？我们可以在 <strong>/sys/fs/cgroup</strong> 中找到它。还是用例子来说明，启动一个容器，设置 <strong>–cpu-shares=512</strong>：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/35.bmp" alt></p><p>查看容器的 ID：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/36.bmp" alt><br>在 /sys/fs/cgroup/cpu/docker 目录中，Linux 会为每个容器创建一个 cgroup 目录，以容器长ID 命名：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/37.bmp" alt><br>目录中包含所有与 cpu 相关的 cgroup 配置，文件 cpu.shares 保存的就是 –cpu-shares 的配置，值为 512。</p><p>同样的，/sys/fs/cgroup/memory/docker 和 /sys/fs/cgroup/blkio/docker 中保存的是内存以及 Block IO 的 cgroup 配置。</p><p><strong>namespace</strong><br>在每个容器中，我们都可以看到文件系统，网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使 host 上只有一块物理网卡。这种方式非常好，它使得容器更像一个独立的计算机。</p><p>Linux 实现这种方式的技术是 namespace。namespace 管理着 host 中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace 实现了容器间资源的隔离。</p><p>Linux 使用了六种 namespace，分别对应六种资源：Mount、UTS、IPC、PID、Network 和 User，下面我们分别讨论。</p><p><strong>Mount namespace</strong><br>Mount namespace 让容器看上去拥有整个文件系统。</p><p>容器有自己的 / 目录，可以执行 mount 和 umount 命令。当然我们知道这些操作只在当前容器中生效，不会影响到 host 和其他容器。</p><p><strong>UTS namespace</strong><br>简单的说，UTS namespace 让容器有自己的 hostname。 默认情况下，容器的 hostname 是它的短ID，可以通过 -h 或 –hostname 参数设置。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/38.bmp" alt></p><p><strong>IPC namespace</strong><br>IPC namespace 让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。</p><p><strong>PID namespace</strong><br>我们前面提到过，容器在 host 中以进程的形式运行。例如当前 host 中运行了两个容器：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/39.bmp" alt><br>通过 ps axf 可以查看容器进程：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/40.bmp" alt><br>所有容器的进程都挂在 dockerd 进程下，同时也可以看到容器自己的子进程。 如果我们进入到某个容器，ps 就只能看到自己的进程了：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/41.bmp" alt><br>而且进程的 PID 不同于 host 中对应进程的 PID，容器中 PID=1 的进程当然也不是 host 的 init 进程。也就是说：容器拥有自己独立的一套 PID，这就是 PID namespace 提供的功能。</p><p><strong>Network namespace</strong><br>Network namespace 让容器拥有自己独立的网卡、IP、路由等资源。我们会在后面网络章节详细讨论。</p><p><strong>User namespace</strong><br>User namespace 让容器能够管理自己的用户，host 不能看到容器中创建的用户。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%AE%B9%E5%99%A8/42.bmp" alt><br>在容器中创建了用户 cloudman，但 host 中并不会创建相应的用户。</p><p><strong>容器的常用操作命令：</strong><br>create      创建容器<br>run         运行容器<br>pause       暂停容器<br>unpause     取消暂停继续运行容器<br>stop        发送 SIGTERM 停止容器<br>kill        发送 SIGKILL 快速停止容器<br>start       启动容器<br>restart     重启容器<br>attach      attach 到容器启动进程的终端<br>exec        在容器中启动新进程，通常使用 “-it” 参数<br>logs        显示容器启动进程的控制台输出，用 “-f” 持续打印<br>rm          从磁盘中删除容器</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求最近的三数之和</title>
      <link href="/2019/08/16/qiu-zui-jin-de-san-shu-zhi-he/"/>
      <url>/2019/08/16/qiu-zui-jin-de-san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><blockquote><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>1、判断题目类型：数组类型<br>2、解决关键：数组指针（左右指针）<br>3、考虑边界值：<br>(1)、三数之和等于target<br>(2)、(正无穷-目标)的绝对值&gt;(和-目标)绝对值—–关键点（用来存储那个接近target的数）<br>(3)、三数之和小于target – 左侧数移动+1<br>(4)、三数之和大于target – 右侧数移动-1</p><h3 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h3><pre><code>class Solution:    def threeSumClosest(self, nums, target):        nums.sort()        res = float(&quot;inf&quot;)        # float(&quot;inf&quot;)代表正无穷，float(&quot;-inf&quot;)代表负无穷        for i in range(0, len(nums)):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            start, end = i + 1, len(nums) - 1            while start &lt; end:                cur = nums[start] + nums[i] + nums[end]                # 第一种情况                if cur == target: return target                # (正无穷-目标)的绝对值&gt;(和-目标)绝对值-----关键点                # 第二种情况                if abs(res - target) &gt; abs(cur - target):                    res = cur                # 第三种情况                if cur &lt; target:                    start += 1                # 第四种情况                elif cur &gt; target:                    end -= 1        return res</code></pre><p>GitHub链接:<a href="https://github.com/lvyunze/Leetcode/blob/master/array/sum_of_the_nearest_three_Numbers.py" target="_blank" rel="noopener">https://github.com/lvyunze/Leetcode/blob/master/array/sum_of_the_nearest_three_Numbers.py</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub结合pycharm多人协作</title>
      <link href="/2019/08/15/github-jie-he-pycharm-duo-ren-xie-zuo/"/>
      <url>/2019/08/15/github-jie-he-pycharm-duo-ren-xie-zuo/</url>
      
        <content type="html"><![CDATA[<p>首先注册GitHub还有安装git这个就不描述了</p><h3 id="Pycharm配置GitHub和git"><a href="#Pycharm配置GitHub和git" class="headerlink" title="Pycharm配置GitHub和git"></a>Pycharm配置GitHub和git</h3><p><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/9.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/10.png" alt></p><h3 id="创建者"><a href="#创建者" class="headerlink" title="创建者"></a>创建者</h3><p>1、创建仓库<br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/1.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/2.png" alt><br>2、使用仓库clone项目<br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/3.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/4.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/5.png" alt><br>3、切换到工作目录就可以实现两个功能了<br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/6.png" alt><br>(1)让本地文件与远程仓库文件同步（commit+push）<br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/7.png" alt><br>(2)让远程仓库文件与本地文件同步（pull）<br><img src="https://github.com/lvyunze/image/raw/master/GitHub%E7%BB%93%E5%90%88pycharm%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/8.png" alt></p><h3 id="协作者"><a href="#协作者" class="headerlink" title="协作者"></a>协作者</h3><p>使用上述的2、3步骤</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>建议使用虚拟环境,在window环境下就使用window的虚拟环境，在Linux环境上部署就使用linux虚拟环境</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多人协作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="/2019/08/15/san-shu-zhi-he/"/>
      <url>/2019/08/15/san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：答案中不可以包含重复的三元组。</strong></p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>1、判断题目类型：数组类型<br>2、解决关键：数组指针（左右指针）<br>3、考虑边界值：<br>第一种情况：左指针+右指针&lt;目标点<br>第二种情况：左指针+右指针&gt;目标点<br>第三种情况：重复<br>左指针-1和左指针相等<br>右指针和右指针+1相等</p><h3 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h3><pre><code>class Solution():    def threeSum(self, nums):        res = []        nums.sort()        for i in range(0, len(nums)):            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            target = 0 - nums[i]            start, end = i + 1, len(nums) - 1            while start &lt; end:                #第一种情况                if nums[start] + nums[end] &gt; target:                    end -= 1                  #第二种情况                elif nums[start] + nums[end] &lt; target:                    start += 1                else:                    res.append((nums[i], nums[start], nums[end]))                    end -= 1                    start += 1                    #第三种情况                    while start &lt; end and nums[end] == nums[end + 1]:                        end -= 1                    while start &lt; end and nums[start] == nums[start - 1]:                        start += 1        return res</code></pre><p>GitHub链接:<a href="https://github.com/lvyunze/Leetcode/blob/master/array/sum_of_three_number.py" target="_blank" rel="noopener">https://github.com/lvyunze/Leetcode/blob/master/array/sum_of_three_number.py</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像篇</title>
      <link href="/2019/08/13/docker-jing-xiang-pian/"/>
      <url>/2019/08/13/docker-jing-xiang-pian/</url>
      
        <content type="html"><![CDATA[<p>注：文章来源于作者：CloudMan<br>书籍：《每天五分钟玩转Docker容器技术》</p><h3 id="最小的镜像"><a href="#最小的镜像" class="headerlink" title="最小的镜像"></a>最小的镜像</h3><p>镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。</p><p>内容如下：</p><p>首先通过研究几个典型的镜像，分析镜像的内部结构。<br>然后学习如何构建自己的镜像。<br>最后介绍怎样管理和分发镜像。</p><p><strong>镜像的内部结构</strong><br>为什么我们要讨论镜像的内部结构？</p><p>如果只是使用镜像，当然不需要了解，直接通过 docker 命令下载和运行就可以了。</p><p>但如果我们想创建自己的镜像，或者想理解 Docker 为什么是轻量级的，就非常有必要学习这部分知识了。</p><p>我们从一个最小的镜像开始吧。<br><strong>hello-world - 最小的镜像</strong></p><p>hello-world 是 Docker 官方提供的一个镜像，通常用来验证 Docker 是否安装成功。</p><p>我们先通过 docker pull 从 Docker Hub 下载它。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/1.bmp" alt><br>用 docker images 命令查看镜像的信息。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/2.bmp" alt><br>hello-world 镜像竟然还不到 2KB!<br>通过 docker run 运行。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/3.bmp" alt></p><p>其实我们更关心 hello-world 镜像包含哪些内容。</p><p>Dockerfile 是镜像的描述文件，定义了如何构建 Docker 镜像。Dockerfile 的语法简洁且可读性强，后面我们会专门讨论如何编写 Dockerfile。</p><p>hello-world 的 Dockerfile 内容如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/4.bmp" alt></p><p>只有短短三条指令。</p><p>1、FROM scratch<br>此镜像是从白手起家，从 0 开始构建。</p><p>2、COPY hello /<br>将文件“hello”复制到镜像的根目录。</p><p>3、CMD [“/hello”]<br>容器启动时，执行 /hello</p><p>镜像 hello-world 中就只有一个可执行文件 “hello”，其功能就是打印出 “Hello from Docker ……” 等信息。</p><p>/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。</p><p>hello-world 虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作 base 镜像。</p><p>我们下一节讨论 base </p><h3 id="base-镜像"><a href="#base-镜像" class="headerlink" title="base 镜像"></a>base 镜像</h3><p>base 镜像有两层含义：<br>1、不依赖其他镜像，从 scratch 构建。<br>2、其他镜像可以之为基础进行扩展。</p><p>所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</p><p>我们以 CentOS 为例考察 base 镜像包含哪些内容。<br>下载镜像：</p><p>docker pull centos</p><p>查看镜像信息：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/5.bmp" alt><br>镜像大小不到 200MB。</p><p>等一下！<br>一个 CentOS 才 200MB ？<br>平时我们安装一个 CentOS 至少都有几个 GB，怎么可能才 200MB !</p><p>相信这是几乎所有 Docker 初学者都会有的疑问，包括我自己。下面我们来解释这个问题。</p><p>Linux 操作系统由内核空间和用户空间组成。如下图所示：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/6.bmp" alt></p><p><strong>rootfs</strong><br>内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。</p><p>用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。</p><p>对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。</p><p>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了，alpine 还不到 10MB。</p><p>我们平时安装的 CentOS 除了 rootfs 还会选装很多软件、服务、图形桌面等，需要好几个 GB 就不足为奇了。</p><p><strong>base 镜像提供的是最小安装的 Linux 发行版。</strong><br>下面是 CentOS 镜像的 Dockerfile 的内容：<br><img src="6https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/7.bmp" alt><br>第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时，这个 tar 包会自动解压到 / 目录下，生成 /dev, /porc, /bin 等目录。</p><p>注：可在 Docker Hub 的镜像描述页面中查看 Dockerfile 。</p><p><strong>支持运行多种 Linux OS</strong><br>不同 Linux 发行版的区别主要就是 rootfs。</p><p>比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。</p><p>所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/8.bmp" alt><br>上图 Debian 和 BusyBox（一种嵌入式 Linux）上层提供各自的 rootfs，底层共用 Docker Host 的 kernel。</p><p>这里需要说明的是：<br>1、base 镜像只是在用户空间与发行版一致，kernel 版本与发型版是不同的。<br>例如 CentOS 7 使用 3.x.x 的 kernel，如果 Docker Host 是 Ubuntu 16.04（比如我们的实验环境），那么在 CentOS 容器中使用的实际是是 Host 4.x.x 的 kernel。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/9.bmp" alt><br>① Host kernel 为 4.4.0-31<br>② 启动并进入 CentOS 容器<br>③ 验证容器是 CentOS 7<br>④ 容器的 kernel 版本与 Host 一致<br>2、容器只能使用 Host 的 kernel，并且不能修改。所有容器都共用 host 的 kernel，在容器中没办法对 kernel 升级。如果容器对 kernel 版本有要求（比如应用只能在某个 kernel 版本下运行），则不建议用容器，这种场景虚拟机可能更合适。</p><h3 id="镜像的分层结构"><a href="#镜像的分层结构" class="headerlink" title="镜像的分层结构"></a>镜像的分层结构</h3><p>Docker 支持通过扩展现有镜像，创建新的镜像。</p><p>实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。比如我们现在构建一个新的镜像，Dockerfile 如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/10.bmp" alt></p><p>① 新镜像不再是从 scratch 开始，而是直接在 Debian base 镜像上构建。<br>② 安装 emacs 编辑器。<br>③ 安装 apache2。<br>④ 容器启动时运行 bash。</p><p>构建过程如下图所示：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/11.bmp" alt><br>可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p>问什么 Docker 镜像要采用这种分层结构呢？</p><p>最大的一个好处就是 - 共享资源。</p><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享，我们将在后面更深入地讨论这个特性。</p><p>这时可能就有人会问了：如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是否也会被修改？</p><p>答案是不会！<br>修改会被限制在单个容器内。<br>这就是我们接下来要学习的容器 Copy-on-Write 特性。<br><strong>可写的容器层</strong><br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/12.jpg" alt><br>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。</p><p><strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong><br>下面我们深入讨论容器层的细节。</p><p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。<br><strong>添加文件</strong><br>在容器中创建文件时，新文件被添加到容器层中。</p><p><strong>读取文件</strong><br>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p><p><strong>修改文件</strong><br>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p><p><strong>删除文件</strong> </p><p>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。<br>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以<strong>镜像可以被多个容器共享</strong>。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>对于 Docker 用户来说，最好的情况是不需要自己创建镜像。几乎所有常用的数据库、中间件、应用软件等都有现成的 Docker 官方镜像或其他人和组织创建的镜像，我们只需要稍作配置就可以直接使用。</p><p>使用现成镜像的好处除了省去自己做镜像的工作量外，更重要的是可以利用前人的经验。特别是使用那些官方镜像，因为 Docker 的工程师知道如何更好的在容器中运行软件。</p><p>当然，某些情况下我们也不得不自己构建镜像，比如：</p><ol><li><p>找不到现成的镜像，比如自己开发的应用程序。</p></li><li><p>需要在镜像中加入特定的功能，比如官方镜像几乎都不提供 ssh。</p></li></ol><p>所以本节我们将介绍构建镜像的方法。同时分析构建的过程也能够加深我们对前面镜像分层结构的理解。</p><p>Docker 提供了两种构建镜像的方法：</p><ol><li>docker commit 命令</li><li>Dockerfile 构建文件</li></ol><p><strong>docker commit</strong><br>docker commit 命令是创建新镜像最直观的方法，其过程包含三个步骤：</p><ol><li>运行容器</li><li>修改容器</li><li>将容器保存为新的镜像</li></ol><p>举个例子：在 ubuntu base 镜像中安装 vi 并保存为新镜像。</p><ol><li>第一步， 运行容器<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/13.bmp" alt></li></ol><p>-it 参数的作用是以交互模式进入容器，并打开终端。412b30588f4a 是容器的内部 ID。</p><ol start="2"><li><p>安装 vi<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/14.bmp" alt><br>确认 vi 没有安装。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/15.bmp" alt><br>安装 vi。</p></li><li><p>保存为新镜像<br>在新窗口中查看当前运行的容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/16.bmp" alt><br>silly_goldberg 是 Docker 为我们的容器随机分配的名字。</p></li></ol><p>执行 docker commit 命令将容器保存为镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/17.bmp" alt><br>新镜像命名为 ubuntu-with-vi。</p><p>查看新镜像的属性。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/18.bmp" alt><br>从 size 上看到镜像因为安装了软件而变大了。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/19.bmp" alt><br>从新镜像启动容器，验证 vi 已经可以使用。<br>以上演示了如何用 docker commit 创建新镜像。然而，Docker 并不建议用户通过这种方式构建镜像。原因如下：<br><strong>1. 这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在 debian base 镜像中也加入 vi，还得重复前面的所有步骤。</strong></p><p><strong>2. 更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。</strong></p><p>既然 docker commit 不是推荐的方法，我们干嘛还要花时间学习呢？</p><p>原因是：即便是用 Dockerfile（推荐方法）构建镜像，底层也 docker commit 一层一层构建新镜像的。学习 docker commit 能够帮助我们更加深入地理解构建过程和镜像的分层结构。</p><h3 id="Dockerfile-构建镜像"><a href="#Dockerfile-构建镜像" class="headerlink" title="Dockerfile 构建镜像"></a>Dockerfile 构建镜像</h3><p>Dockerfile 是一个文本文件，记录了镜像构建的所有步骤。</p><p><strong>第一个 Dockerfile</strong></p><p>用 Dockerfile 创建上节的 ubuntu-with-vi，其内容则为：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/20.bmp" alt></p><p>下面我们运行 docker build 命令构建镜像并详细分析每个细节。</p><p>root@ubuntu:<del># pwd         ①<br>/root<br>root@ubuntu:</del># ls          ②<br>Dockerfile<br>root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile .        ③<br>Sending build context to Docker daemon 32.26 kB           ④<br>Step 1 : FROM ubuntu           ⑤<br> —&gt; f753707788c5<br>Step 2 : RUN apt-get update &amp;&amp; apt-get install -y vim           ⑥<br> —&gt; Running in 9f4d4166f7e3             ⑦   </p><p>……   </p><p>Setting up vim (2:7.4.1689-3ubuntu1.1) …<br> —&gt; 35ca89798937           ⑧<br>Removing intermediate container 9f4d4166f7e3          ⑨<br>Successfully built 35ca89798937           ⑩<br>root@ubuntu:~#   </p><p>① 当前目录为 /root。</p><p>② Dockerfile 准备就绪。</p><p>③ 运行 docker build 命令，-t 将新镜像命名为 ubuntu-with-vi-dockerfile，命令末尾的 . 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 -f 参数指定 Dockerfile 的位置。</p><p>④ 从这步开始就是镜像真正的构建过程。 首先 Docker 将 build context 中的所有文件发送给 Docker daemon。build context 为镜像构建提供所需要的文件或目录。<br>Dockerfile 中的 ADD、COPY 等命令可以将 build context 中的文件添加到镜像。此例中，build context 为当前目录 /root，该目录下的所有文件和子目录都会被发送给 Docker daemon。</p><p>所以，使用 build context 就得小心了，不要将多余文件放到 build context，特别不要把 /、/usr 作为 build context，否则构建过程会相当缓慢甚至失败。</p><p>⑤ Step 1：执行 FROM，将 ubuntu 作为 base 镜像。<br>ubuntu 镜像 ID 为 f753707788c5。</p><p>⑥ Step 2：执行 RUN，安装 vim，具体步骤为 ⑦、⑧、⑨。</p><p>⑦ 启动 ID 为 9f4d4166f7e3 的临时容器，在容器中通过 apt-get 安装 vim。</p><p>⑧ 安装成功后，将容器保存为镜像，其 ID 为 35ca89798937。<br>这一步底层使用的是类似 docker commit 的命令。</p><p>⑨ 删除临时容器 9f4d4166f7e3。</p><p>⑩ 镜像构建成功。<br>通过 docker images 查看镜像信息。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/21.bmp" alt></p><p>镜像 ID 为 35ca89798937，与构建时的输出一致。</p><p>在上面的构建过程中，我们要特别注意指令 RUN 的执行过程 ⑦、⑧、⑨。Docker 会在启动的临时容器中执行操作，并通过 commit 保存为新的镜像。</p><p><strong>查看镜像分层结构</strong></p><p>ubuntu-with-vi-dockerfile 是通过在 base 镜像的顶部添加一个新的镜像层而得到的。</p><p><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/22.bmp" alt><br>这个新镜像层的内容由 RUN apt-get update &amp;&amp; apt-get install -y vim 生成。这一点我们可以通过 docker history 命令验证。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/23.bmp" alt><br>docker history 会显示镜像的构建历史，也就是 Dockerfile 的执行过程。</p><p>ubuntu-with-vi-dockerfile 与 ubuntu 镜像相比，确实只是多了顶部的一层 35ca89798937，由 apt-get 命令创建，大小为 97.07MB。docker history 也向我们展示了镜像的分层结构，每一层由上至下排列。</p><p>注： 表示无法获取 IMAGE ID，通常从 Docker Hub 下载的镜像会有这个问题。</p><h3 id="镜像的缓存特性"><a href="#镜像的缓存特性" class="headerlink" title="镜像的缓存特性"></a>镜像的缓存特性</h3><p>Docker 会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无需重新创建。</p><p>举例说明。<br>在前面的 Dockerfile 中添加一点新内容，往镜像中复制一个文件：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/24.bmp" alt></p><pre><code>root@ubuntu:~# ls           ①Dockerfile  testfileroot@ubuntu:~#root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile-2 .Sending build context to Docker daemon 32.77 kBStep 1 : FROM ubuntu ---&gt; f753707788c5Step 2 : RUN apt-get update &amp;&amp; apt-get install -y vim ---&gt; Using cache         ② ---&gt; 35ca89798937Step 3 : COPY testfile /          ③ ---&gt; 8d02784a78f4Removing intermediate container bf2b4040f4e9Successfully built 8d02784a78f4</code></pre><p>① 确保 testfile 已存在。</p><p>② <strong>重点在这里</strong>：之前已经运行过相同的 RUN 指令，这次直接使用缓存中的镜像层 35ca89798937。</p><p>③ 执行 COPY 指令。<br>其过程是启动临时容器，复制 testfile，提交新的镜像层 8d02784a78f4，删除临时容器。</p><p>在 ubuntu-with-vi-dockerfile 镜像上直接添加一层就得到了新的镜像 ubuntu-with-vi-dockerfile-2。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/25.bmp" alt><br>如果我们希望在构建镜像时不使用缓存，可以在 <strong>docker build</strong> 命令中加上 <strong>–no-cache</strong> 参数。</p><p>Dockerfile 中每一个指令都会创建一个镜像层，上层是依赖于下层的。无论什么时候，只要某一层发生变化，其上面所有层的缓存都会失效。</p><p>也就是说，如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。</p><p>举例说明，比如交换前面 RUN 和 COPY 的顺序：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/26.bmp" alt><br>虽然在逻辑上这种改动对镜像的内容没有影响，但由于分层的结构特性，Docker 必须重建受影响的镜像层。</p><pre><code>root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile-3 .Sending build context to Docker daemon 37.89 kBStep 1 : FROM ubuntu ---&gt; f753707788c5Step 2 : COPY testfile / ---&gt; bc87c9710f40Removing intermediate container 04ff324d6af5Step 3 : RUN apt-get update &amp;&amp; apt-get install -y vim ---&gt; Running in 7f0fcb5ee373Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]......</code></pre><p>从上面的输出可以看到生成了新的镜像层 bc87c9710f40，缓存已经失效。</p><p>除了构建时使用缓存，Docker 在下载镜像时也会使用。例如我们下载 httpd 镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/27.bmp" alt><br>docker pull 命令输出显示第一层（base 镜像）已经存在，不需要下载。</p><p>由 Dockerfile 可知 httpd 的 base 镜像为 debian，正好之前已经下载过 debian 镜像，所以有缓存可用。通过 docker history 可以进一步验证。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/28.bmp" alt></p><h3 id="调试-Dockerfile"><a href="#调试-Dockerfile" class="headerlink" title="调试 Dockerfile"></a>调试 Dockerfile</h3><p>包括 Dockerfile 在内的任何脚本和程序都会出错。有错并不可怕，但必须有办法排查，所以本节讨论如何 debug Dockerfile。</p><p>先回顾一下通过 Dockerfile 构建镜像的过程：</p><p>1、从 base 镜像运行一个容器。<br>2、执行一条指令，对容器做修改。<br>3、执行类似 docker commit 的操作，生成一个新的镜像层。<br>4、Docker 再基于刚刚提交的镜像运行一个新容器。<br>5、重复 2-4 步，直到 Dockerfile 中的所有指令执行完毕。</p><p>从这个过程可以看出，如果 Dockerfile 由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试 Dockerfile 非常有帮助。我们可以运行最新的这个镜像定位指令失败的原因。</p><p>我们来看一个调试的例子。Dockerfile 内容如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/29.bmp" alt><br>执行 docker build：</p><p><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/30.bmp" alt><br>Dockerfile 在执行第三步 RUN 指令时失败。我们可以利用第二步创建的镜像 22d31cc52b3e 进行调试，方式是通过 docker run -it 启动镜像的一个容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/31.bmp" alt><br>手工执行 RUN 指令很容易定位失败的原因是 busybox 镜像中没有 bash。虽然这是个极其简单的例子，但它很好地展示了调试 Dockerfile 的方法。</p><h3 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h3><p><strong>FROM</strong><br>指定 base 镜像。</p><p><strong>MAINTAINER</strong><br>设置镜像的作者，可以是任意字符串。</p><p><strong>COPY</strong><br>将文件从 build context 复制到镜像。<br>COPY 支持两种形式：</p><p>COPY src dest</p><p>COPY [“src”, “dest”]</p><p>注意：src 只能指定 build context 中的文件或目录。</p><p><strong>ADD</strong><br>与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。</p><p><strong>ENV</strong><br>设置环境变量，环境变量可被后面的指令使用。例如：</p><pre><code>ENV MY_VERSION 1.3RUN apt-get install -y mypackage=$MY_VERSION</code></pre><p><strong>EXPOSE</strong><br>指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。我们会在容器网络部分详细讨论。</p><p><strong>VOLUME</strong><br>将文件或目录声明为 volume。我们会在容器存储部分详细讨论。</p><p><strong>WORKDIR</strong><br>为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。</p><p><strong>RUN</strong><br>在容器中运行指定的命令。</p><p><strong>CMD</strong><br>容器启动时运行指定的命令。</p><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。</p><p><strong>ENTRYPOINT</strong><br>设置容器启动时运行的命令。<br>Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。</p><p>下面我们来看一个较为全面的 Dockerfile：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/32.bmp" alt><br>注：Dockerfile 支持以“#”开头的注释。</p><p>构建镜像：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/33.bmp" alt><br>① 构建前确保 build context 中存在需要的文件。</p><p>② 依次执行 Dockerfile 指令，完成构建。</p><p>运行容器，验证镜像内容<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/34.bmp" alt><br>① 进入容器，当前目录即为 WORKDIR。<br>如果 WORKDIR 不存在，Docker 会自动为我们创建。</p><p>② WORKDIR 中保存了我们希望的文件和目录：<br>目录 bunch：由 ADD 指令从 build context 复制的归档文件 bunch.tar.gz，已经自动解压。<br>文件 tmpfile1：由 RUN 指令创建。<br>文件 tmpfile2：由 COPY 指令从 build context 复制。</p><p>③ ENV 指令定义的环境变量已经生效。</p><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。<br>简单的说：</p><p>1、RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p><p>2、CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</p><p>3、ENTRYPOINT 配置容器启动时运行的命令。</p><p>下面我们详细分析。</p><p><strong>Shell 和 Exec 格式</strong><br>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p><p>简单的说：</p><p>1、RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p><p>2、CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</p><p>3、ENTRYPOINT 配置容器启动时运行的命令。</p><p>下面我们详细分析。<br><strong>Shell 和 Exec 格式</strong><br>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p><blockquote><p>Shell 格式<br><instruction> <command></instruction></p></blockquote><blockquote></blockquote><p>例如：<br>RUN apt-get install python3<br>CMD echo “Hello world”<br>ENTRYPOINT echo “Hello world”</p><p>当指令执行时，shell 格式底层会调用 /bin/sh -c <command>。</p><p>例如下面的 Dockerfile 片段：</p><pre><code>ENV name yunze  ENTRYPOINT echo &quot;Hello, $name&quot; </code></pre><p>执行 docker run <image> 将输出：</image></p><p>Hello, yunze</p><p>注意环境变量 name 已经被值 yunze 替换。</p><p>下面来看 Exec 格式。<br>Exec 格式<br><instruction> [“executable”, “param1”, “param2”, …]</instruction></p><p>例如：</p><pre><code>RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;python3&quot;]  CMD [&quot;/bin/echo&quot;, &quot;Hello world&quot;]  ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello world&quot;]</code></pre><p>当指令执行时，会直接调用 <command>，不会被 shell 解析。<br>例如下面的 Dockerfile 片段：</p><pre><code>ENV name yunzeENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;]</code></pre><p>运行容器将输出：</p><pre><code>Hello, $name</code></pre><p><strong>注意</strong>环境变量“name”没有被替换。<br>如果希望使用环境变量，照如下修改</p><pre><code>ENV name yunze ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello, $name&quot;]</code></pre><p>运行容器将输出：</p><pre><code>Hello, yunze</code></pre><p><strong>CMD 和 ENTRYPOINT 推荐使用 Exec 格式</strong>，因为指令可读性更强，更容易理解。RUN 则两种格式都可以。</p><p><strong>RUN</strong><br>RUN 指令通常用于安装应用和软件包。</p><p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p><p>RUN 有两种格式：</p><p>Shell 格式：RUN<br>Exec 格式：RUN [“executable”, “param1”, “param2”]<br>下面是使用 RUN 安装多个包的例子：</p><pre><code>RUN apt-get update &amp;&amp; apt-get install -y \   bzr \ cvs \ git \ mercurial \ subversion</code></pre><p>注意：apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p><p><strong>CMD</strong><br>CMD 指令允许用户指定容器的默认执行的命令。</p><p>此命令会在容器启动且 docker run 没有指定其他命令时运行。</p><p>1、如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</p><p>2、如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</p><p>CMD 有三种格式：</p><p>1、Exec 格式：CMD [“executable”,”param1”,”param2”]<br>这是 CMD 的推荐格式。</p><p>2、CMD [“param1”,”param2”] 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</p><p>3、Shell 格式：CMD command param1 param2</p><p>Exec 和 Shell 格式前面已经介绍过了。<br>第二种格式 CMD [“param1”,”param2”] 要与 Exec 格式 的 ENTRYPOINT 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p><p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：</p><blockquote><p>CMD echo “Hello world”</p></blockquote><p>运行容器 docker run -it [image] 将输出：</p><blockquote><p>Hello world</p></blockquote><p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行：</p><blockquote><p>root@10a32dc7d3d3:/#</p></blockquote><p><strong>ENTRYPOINT</strong><br>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p><p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p><p>ENTRYPOINT 有两种格式：</p><p>1、Exec 格式：ENTRYPOINT [“executable”, “param1”, “param2”] 这是 ENTRYPOINT 的推荐格式。</p><p>2、Shell 格式：ENTRYPOINT command param1 param2</p><p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p><p><strong>Exec 格式</strong><br>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p><p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p><p>比如下面的 Dockerfile 片段：</p><pre><code>ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello&quot;]  CMD [&quot;world&quot;]</code></pre><p>当容器通过 docker run -it [image] 启动时，输出为：</p><pre><code>Hello world</code></pre><p>而如果通过 docker run -it [image] yunze 启动，则输出为：</p><pre><code>Hello yunze</code></pre><p><strong>Shell 格式</strong><br>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p><p><strong>最佳实践</strong><br>1、使用 RUN 指令安装应用和软件包，构建镜像。<br>2、如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。<br>3、如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</p><p><strong>镜像命名的最佳实践</strong><br>我们已经学会构建自己的镜像了。接下来的问题是如何在多个 Docker Host 上使用镜像。<br>这里有几种可用的方法：</p><p>1、用相同的 Dockerfile 在其他 host 构建镜像。</p><p>2、将镜像上传到公共 Registry（比如 Docker Hub），Host 直接下载使用。</p><p>3、搭建私有的 Registry 供本地 Host 使用。</p><p>第一种方法没什么特别的，前面已经讨论很多了。我们将讨论如何使用公共和私有 Registry 分发镜像。</p><p><strong>为镜像命名</strong><br>无论采用何种方式保存和分发镜像，首先都得给镜像命名。</p><p>当我们执行 docker build 命令时已经为镜像取了个名字，例如前面：</p><blockquote><p>docker build -t ubuntu-with-vi</p></blockquote><p>这里的 ubuntu-with-vi 就是镜像的名字。通过 dock images 可以查看镜像的信息。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/35.bmp" alt><br>这里注意到 ubuntu-with-vi 对应的是 REPOSITORY，而且还有一个叫 latest 的 TAG。</p><p>实际上一个特定镜像的名字由两部分组成：repository 和 tag。</p><blockquote><p>[image name] = [repository]:[tag]</p></blockquote><p>如果执行 docker build 时没有指定 tag，会使用默认值 latest。其效果相当于：</p><blockquote><p>docker build -t ubuntu-with-vi:latest</p></blockquote><p>tag 常用于描述镜像的版本信息，比如 httpd 镜像：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/36.bmp" alt></p><p>当然 tag 可以是任意字符串，比如 ubuntu 镜像：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/37.bmp" alt></p><p><strong>小心 latest tag</strong></p><p>千万别被 latest tag 给误导了。latest 其实并没有什么特殊的含义。当没指明镜像 tag 时，Docker 会使用默认值 latest，仅此而已。</p><p>虽然 Docker Hub 上很多 repository 将 latest 作为最新稳定版本的别名，但这只是一种约定，而不是强制规定。</p><p>所以我们在使用镜像时最好还是避免使用 latest，明确指定某个 tag，比如 httpd:2.3，ubuntu:xenial。</p><p><strong>tag 使用最佳实践</strong><br>借鉴软件版本命名方式能够让用户很好地使用镜像。</p><p>一个高效的版本命名方案可以让用户清楚地知道当前使用的是哪个镜像，同时还可以保持足够的灵活性。</p><p>每个 repository 可以有多个 tag，而多个 tag 可能对应的是同一个镜像。下面通过例子为大家介绍 Docker 社区普遍使用的 tag 方案。</p><p>假设我们现在发布了一个镜像 myimage，版本为 v1.9.1。那么我们可以给镜像打上四个 tag：1.9.1、1.9、1 和 latest。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/38.bmp" alt><br>我们可以通过 docker tag 命令方便地给镜像打 tag。</p><blockquote><p>docker tag myimage-v1.9.1 myimage:1<br>docker tag myimage-v1.9.1 myimage:1.9<br>docker tag myimage-v1.9.1 myimage:1.9.1<br>docker tag myimage-v1.9.1 myimage:latest</p></blockquote><p>过了一段时间，我们发布了 v1.9.2。这时可以打上 1.9.2 的 tag，并将 1.9、1 和 latest 从 v1.9.1 移到 v1.9.2。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/39.bmp" alt></p><blockquote><p>命令为：<br>docker tag myimage-v1.9.2 myimage:1<br>docker tag myimage-v1.9.2 myimage:1.9<br>docker tag myimage-v1.9.2 myimage:1.9.2<br>docker tag myimage-v1.9.2 myimage:latest</p></blockquote><p>之后，v2.0.0 发布了。这时可以打上 2.0.0、2.0 和 2 的 tag，并将 latest 移到 v2.0.0。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/40.bmp" alt></p><blockquote><p>命令为：<br>docker tag myimage-v2.0.0 myimage:2<br>docker tag myimage-v2.0.0 myimage:2.0<br>docker tag myimage-v2.0.0 myimage:2.0.0<br>docker tag myimage-v2.0.0 myimage:latest</p></blockquote><p>这种 tag 方案使镜像的版本很直观，用户在选择非常灵活：</p><p>1、myimage:1 始终指向 1 这个分支中最新的镜像。<br>2、myimage:1.9 始终指向 1.9.x 中最新的镜像。<br>3、myimage:latest 始终指向所有版本中最新的镜像。<br>4、如果想使用特定版本，可以选择 myimage:1.9.1、myimage:1.9.2 或 myimage:2.0.0。</p><h3 id="使用公共-Registry"><a href="#使用公共-Registry" class="headerlink" title="使用公共 Registry"></a>使用公共 Registry</h3><p>保存和分发镜像的最直接方法就是使用 Docker Hub。</p><p>Docker Hub 是 Docker 公司维护的公共 Registry。用户可以将自己的镜像保存到 Docker Hub 免费的 repository 中。如果不希望别人访问自己的镜像，也可以购买私有 repository。</p><p>除了 Docker Hub，quay.io 是另一个公共 Registry，提供与 Docker Hub 类似的服务。<br>下面介绍如何用 Docker Hub 存取我们的镜像。</p><p>1、首先得在 Docker Hub 上注册一个账号。</p><p>2、在 Docker Host 上登录。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/41.bmp" alt><br>这里用的是我自己的账号，用户名为 cloudman6，输入密码后登录成功。</p><p>3、修改镜像的 repository 使之与 Docker Hub 账号匹配。</p><p>Docker Hub 为了区分不同用户的同名镜像，镜像的 registry 中要包含用户名，完整格式为：[username]/xxx:tag</p><p>我们通过 docker tag 命令重命名镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/42.bmp" alt><br>注：Docker 官方自己维护的镜像没有用户名，比如 httpd。</p><p>4、通过 docker push 将镜像上传到 Docker Hub。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/43.bmp" alt><br>Docker 会上传镜像的每一层。因为 cloudman6/httpd:v1 这个镜像实际上跟官方的 httpd 镜像一模一样，Docker Hub 上已经有了全部的镜像层，所以真正上传的数据很少。同样的，如果我们的镜像是基于 base 镜像的，也只有新增加的镜像层会被上传。如果想上传同一 repository 中所有镜像，省略 tag 部分就可以了，例如<br>docker push cloudman6/httpd</p><p>5、登录 <a href="https://hub.docker.com，在Public" target="_blank" rel="noopener">https://hub.docker.com，在Public</a> Repository 中就可以看到上传的镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/44.bmp" alt></p><p>6、这个镜像可被其他 Docker host 下载使用了。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/45.bmp" alt></p><h3 id="搭建本地-Registry"><a href="#搭建本地-Registry" class="headerlink" title="搭建本地 Registry"></a>搭建本地 Registry</h3><p>Docker Hub 虽然非常方便，但还是有些限制，比如：</p><p>1、需要 internet 连接，而且下载和上传速度慢。</p><p>2、上传到 Docker Hub 的镜像任何人都能够访问，虽然可以用私有 repository，但不是免费的。</p><p>3、安全原因很多组织不允许将镜像放到外网。</p><p>解决方案就是搭建本地的 Registry。</p><p>Docker 已经将 Registry 开源了，同时在 Docker Hub 上也有官方的镜像 registry。下面我们就在 Docker 中运行自己的 registry。</p><p>1、启动 registry 容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/46.bmp" alt><br>我们使用的镜像是 <strong>registry:2</strong></p><p><strong>-d</strong> 是后台启动容器。</p><p><strong>-p</strong> 将容器的 5000 端口映射到 Host 的 5000 端口。5000 是 registry 服务端口。端口映射我们会在容器网络章节详细讨论。</p><p><strong>-v</strong> 将容器 /var/lib/registry 目录映射到 Host 的 /myregistry，用于存放镜像数据。-v 的使用我们会在容器存储章节详细讨论。</p><p>2、通过 docker tag 重命名镜像，使之与 registry 匹配。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/47.bmp" alt><br>我们在镜像的前面加上了运行 registry 的主机名称和端口。</p><p>前面已经讨论了镜像名称由 repository 和 tag 两部分组成。而 repository 的完整格式为：[registry-host]:[port]/[username]/xxx</p><p>只有 Docker Hub 上的镜像可以省略 [registry-host]:[port] 。</p><p>3、通过 docker push 上传镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/48.bmp" alt></p><p>4、现在已经可通过 docker pull 从本地 registry 下载镜像了。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/49.bmp" alt><br>除了镜像的名称长一些（包含 registry host 和 port），使用方式完全一样。</p><p>以上是搭建本地 registry 的简要步骤。当然 registry 也支持认证，https 安全传输等特性，具体可以参考官方文档 <a href="https://docs.docker.com/registry/configuration/" target="_blank" rel="noopener">https://docs.docker.com/registry/configuration/</a></p><p><strong>Docker 镜像小结</strong><br>这一部分我们首先讨论了镜像的分层结构，然后学习了如何构建镜像，最后实践使用 Docker Hub 和本地 registry。</p><p>下面是镜像的常用操作子命令：</p><pre><code>images    显示镜像列表history   显示镜像构建历史commit    从容器创建新镜像build     从 Dockerfile 构建镜像tag       给镜像打 tagpull      从 registry 下载镜像push      将 镜像 上传到 registryrmi       删除 Docker host 中的镜像search    搜索 Docker Hub 中的镜像</code></pre><p>除了 rmi 和 search，其他命令都已经用过了。</p><p><strong>rmi</strong><br>rmi 只能删除 host 上的镜像，不会删除 registry 的镜像。</p><p>如果一个镜像对应了多个 tag，只有当最后一个 tag 被删除时，镜像才被真正删除。例如 host 中 debian 镜像有两个 tag：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/50.bmp" alt><br>删除其中 debian:latest 只是删除了 latest tag，镜像本身没有删除。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/51.bmp" alt><br>只有当 debian:jessie 也被删除时，整个镜像才会被删除。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/52.bmp" alt><br><strong>search</strong><br>search 让我们无需打开浏览器，在命令行中就可以搜索 Docker Hub 中的镜像。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E9%95%9C%E5%83%8F%E7%AF%87/53.bmp" alt><br>当然，如果想知道镜像都有哪些 tag，还是得访问 Docker Hub。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker镜像篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker启动</title>
      <link href="/2019/08/13/docker-qi-dong/"/>
      <url>/2019/08/13/docker-qi-dong/</url>
      
        <content type="html"><![CDATA[<p>容器启动过程如下：<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%90%AF%E5%8A%A8/1.bmp" alt><br>1、Docker 客户端执行 docker run 命令。<br>2、Docker daemon 发现本地没有 httpd 镜像。<br>3、daemon 从 Docker Hub 下载镜像。<br>4、下载完成，镜像 httpd 被保存到本地。<br>5、Docker daemon 启动容器。<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%90%AF%E5%8A%A8/2.bmp" alt><br><strong>docker images</strong> 可以查看到 httpd 已经下载到本地。<br><strong>docker ps</strong> 或者 <strong>docker container ls</strong> 显示容器正在运行<br><img src="https://github.com/lvyunze/image/raw/master/docker%E5%90%AF%E5%8A%A8/3.bmp" alt></p><blockquote><p>Docker 借鉴了集装箱的概念。标准集装箱将货物运往世界各地，Docker 将这个模型运用到自己的设计哲学中，唯一不同的是：集装箱运输货物，而 Docker 运输软件。</p></blockquote><p>每个容器都有一个软件镜像，相当于集装箱中的货物。容器可以被创建、启动、关闭和销毁。和集装箱一样，Docker 在执行这些操作时，并不关心容器里到底装的什么，它不管里面是 Web Server，还是 Database。</p><p>用户不需要关心容器最终会在哪里运行，因为哪里都可以运行。</p><p>开发人员可以在笔记本上构建镜像并上传到 Registry，然后 QA 人员将镜像下载到物理或虚拟机做测试，最终容器会部署到生产环境。</p><p>使用 Docker 以及容器技术，我们可以快速构建一个应用服务器、一个消息中间件、一个数据库、一个持续集成环境。因为 Docker Hub 上有我们能想到的几乎所有的镜像。</p><p><strong>想研究负载均衡软件 HAProxy，只需要执行docker run haproxy，无需繁琐的手工安装和配置既可以直接进入实战~</strong></p><p><strong>用 django 开发 Python Web 应用，执行 docker run django，在容器里随便折腾，不用担心会搞乱 Host 的环境~</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器路线图</title>
      <link href="/2019/08/13/rong-qi-lu-xian-tu/"/>
      <url>/2019/08/13/rong-qi-lu-xian-tu/</url>
      
        <content type="html"><![CDATA[<p>图片本人制作，使用请说明出处<br><img src="https://user-gold-cdn.xitu.io/2019/8/12/16c8435c7e35dc4e?w=921&h=1519&f=png&s=90380" alt></p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议的分析</title>
      <link href="/2019/08/12/http-xie-yi-de-fen-xi/"/>
      <url>/2019/08/12/http-xie-yi-de-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="http协议的分析"><a href="#http协议的分析" class="headerlink" title="http协议的分析"></a>http协议的分析</h2><p>当我们在地址栏输入<a href="http://www.sina.com.cn/" target="_blank" rel="noopener">http://www.sina.com.cn/</a> 时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，找到<a href="http://www.sina.com那条记录，点击，右侧将显示Request" target="_blank" rel="noopener">www.sina.com那条记录，点击，右侧将显示Request</a> Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求：</p><h3 id="浏览器请求"><a href="#浏览器请求" class="headerlink" title="浏览器请求"></a>浏览器请求</h3><p><img src="https://github.com/lvyunze/image/raw/master/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E6%9E%90/1.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E6%9E%90/2.png" alt><br><strong>说明</strong><br>最主要的头两行分析如下，第一行：</p><blockquote><p>   GET / HTTP/1.1</p></blockquote><p>GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p><p>从第二行开始，每一行都类似于Xxx: abcdefg：</p><blockquote><p>   Host: <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></p></blockquote><p>表示请求的域名是<a href="http://www.sina.com。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。" target="_blank" rel="noopener">www.sina.com。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。</a></p><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据：<br><img src="https://github.com/lvyunze/image/raw/master/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E6%9E%90/3.png" alt><br>HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下：</p><blockquote><pre><code>HTTP/1.1 200 OK</code></pre></blockquote><p>200表示一个成功的响应，后面的OK是说明。</p><p>如果返回的不是200，那么往往有其他的功能，例如</p><p>*失败的响应有404 Not Found：网页不存在<br>*500 Internal Server Error：服务器内部出错<br>*…等等…</p><blockquote><p> Content-Type: text/html</p></blockquote><p>Content-Type指示响应的内容，这里是text/html表示HTML网页。</p><blockquote><p>请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是<a href="http://www.baidu.com/meimei.jpg" target="_blank" rel="noopener">http://www.baidu.com/meimei.jpg</a> ，它也不一定就是图片。</p></blockquote><p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码：<br><img src="https://github.com/lvyunze/image/raw/master/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E6%9E%90/4.png" alt></p><h3 id="浏览器解析过程"><a href="#浏览器解析过程" class="headerlink" title="浏览器解析过程"></a>浏览器解析过程</h3><blockquote><p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。</p></blockquote><p><img src="https://github.com/lvyunze/image/raw/master/http%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E6%9E%90/5.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全</title>
      <link href="/2019/08/12/web-an-quan/"/>
      <url>/2019/08/12/web-an-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的web攻击"><a href="#常见的web攻击" class="headerlink" title="常见的web攻击"></a>常见的web攻击</h2><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><p>CSRF(Cross-site request forgery), 中文名称：<strong>跨站请求伪造</strong>，也被称为：one click attack/session riding， 缩写为：CSRF/XSRF</p><p>CSRF 可以简单理解为：攻击者盗用了你的身份，以你的名义发送恶意请求，容易造成个人隐私泄露以及财产安全~<br><img src="https://github.com/lvyunze/image/raw/master/web%E5%AE%89%E5%85%A8/1.png" alt="CSRF"><br>如上图所示：要完成一次 CSRF 攻击，受害者必须完成：<br><strong>1、登录受信任网站，并在本地生成 cookie</strong><br><strong>2、在不登出 A 的情况下，访问危险网站 B</strong><br>举个简单的例子：</p><p>某银行网站 A，它以 GET 请求来完成银行转账的操作，如：</p><pre><code>http://www.mybank.com/transfer.php?toBankId=11&amp;money=1000</code></pre><p>而某危险网站 B，它页面中含有一段 HTML 代码如下：</p><pre><code>&lt;img src=http://www.mybank.com/transfer.php?toBankId=11&amp;money=1000&gt;</code></pre><p>某一天，你登录了银行网站 A，然后又访问了危险网站 B，这时候你突然发现你的银行账号少了 1000 块，原因是银行网站 A 违反了 HTTP 规范，使用 GET 请求更新资源。B 中的<strong><img></strong>以 GET 方式请求第三方资源(指银行网站，这原本是一个合法的请求，但被不法分子利用了)，由于你此前登录银行网站 A 且还未退出，这时候你的浏览器会带上你的银行网站 A 的 Cookie 发出 GET 请求，结果银行服务器收到请求后，认为这是一条合法的更新资源的操作，所以立刻进行转账操作，这样就完成了一次简单的跨站请求伪造。<br>银行发现这个问题后，决定把获取请求数据的方法改为 POST 请求，只获取 POST 请求的数据，后台处理页面 transfer.php 代码如下：</p><pre><code>&lt;?php    session_start();    if (isset($_POST[&#39;toBankId&#39;] &amp;&amp;isset($_POST[&#39;money&#39;]))    {        transfer($_POST[&#39;toBankId&#39;],　$_POST[&#39;money&#39;]);    }</code></pre><p>这样网站 B 就无法通过简单的 POST 请求来完成转账请求了。然而，危险网站 B 与时俱进，将其页面代码修改了下：</p><pre><code>&lt;body onload=&quot;steal()&quot;&gt;    &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;　　     &lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/transfer.php&quot;&gt;　　        &lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;　　        &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;　　     &lt;/form&gt;    &lt;/iframe&gt;&lt;/body&gt;</code></pre><p>因为这里危险网站 B 暗地里发送了 POST 请求到银行，通过一个隐藏的自动提交的表单来提交请求，同样地完成了转账操作。<br><strong>可以看出，CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。</strong></p><h4 id="那么如何进行-CSRF-防御呢？"><a href="#那么如何进行-CSRF-防御呢？" class="headerlink" title="那么如何进行 CSRF 防御呢？"></a>那么如何进行 CSRF 防御呢？</h4><p>CSRF 防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般 CSRF 防御液都在服务端进行的。</p><ul><li><p>关键操作只接受 POST 请求</p></li><li><p>验证码：<br>CSRF 攻击的过程，往往是在用户不知情的情况下发生的，在用户不知情的情况下构造网络请求，所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 的攻击。<br>但是如果一个网站作出任何举动都要输入验证码的话会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</p></li><li><p>检测 Referer：<br>常见的互联网页面与页面之间是存在联系的，比如你在 腾讯首页 应该找不到通往 <a href="http://www.facebook.com" target="_blank" rel="noopener">http://www.facebook.com</a> 的链接的，比如你在某论坛留言，那么不管你留言之后重定向到哪里，之前的网址一定保留在新页面中 Referer 属性中。</p></li></ul><p>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击</p><ul><li>Token：目前主流的做法是使用 Token 防御 CSRF 攻击<br>CSRF 攻击要成功的条件在于攻击者能够准确地预测所有的参数从而构造出合法的请求，所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击，可以保存其原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击，所以我们在构造请求时候只需要保证：</li><li>Token 要足够随机，使攻击者无法准确预测</li><li>Token 是一次性的，即每次请求成功后要更新 Token，增加预测难度</li><li>Token 要主要保密性，敏感操作使用 POST，防止 Token 出现在 URL 中</li><li><ul><li>最后值得注意的是，过滤用户输入的内容不能阻挡 CSRF 攻击，我们需要做的事过滤请求的来源，因为有些请求是合法，有些是非法的，所以 CSRF 防御主要是过滤那些非法伪造的请求来源。**<h3 id="XSS-攻击："><a href="#XSS-攻击：" class="headerlink" title="XSS 攻击："></a>XSS 攻击：</h3></li></ul></li><li><em>XSS 又称为 CSS，全程为 Cross-site script，跨站脚本攻击，为了和 CSS 层叠样式表区分所以取名为 XSS，是 Web 程序中常见的漏洞。*</em><br>其原理是攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时候，该段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户的 Cookie，破坏页面结构，重定向到其它网站等。</li></ul><p>例如：某论坛的评论功能没有对 XSS 进行过滤，那么我们可以对其进行评论，评论如下：</p><pre><code>&lt;script&gt;while(true) {    alert(&#39;你关不掉我&#39;);}&lt;/script&gt;</code></pre><p>在发布评论中含有 JS 的内容文本，这时候如果服务器没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这段脚本。</p><p>这只是一个简单的小例子，恶意着可以将上述代码修改为恶意的代码，就可以盗取你的 Cookie 或者其它信息了。</p><p>XSS 类型：</p><p>一般可以分为： 持久型 XSS 和非持久性 XSS</p><p>持久型 XSS 就是对客户端攻击的脚本植入到服务器上，从而导致每个正常访问到的用户都会遭到这段 XSS 脚本的攻击。(如上述的留言评论功能)</p><p>非持久型 XSS 是对一个页面的 URL 中的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数重，再将这个 URL 发布到网上，骗取用户访问，从而进行攻击</p><p>非持久性 XSS 的安全威胁比较小，因为只要服务器调整业务代码进行过滤，黑客精心构造的这段 URL 就会瞬间失效了，而相比之下，持久型 XSS 的攻击影响力很大，有时候服务端需要删好几张表，查询很多库才能将恶意代码的数据进行删除。</p><h4 id="如何防御-XSS-攻击？"><a href="#如何防御-XSS-攻击？" class="headerlink" title="如何防御 XSS 攻击？"></a>如何防御 XSS 攻击？</h4><p>理论上，网站上所有可输入的地方没有对输入内容进行处理的话，都会存在 XSS 漏洞，漏洞的危险取决于攻击代码的威力，攻击代码也不局限于 script，防御 XSS 攻击最简单直接的方法就是过滤用户的输入。</p><ul><li>如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML 转义：<pre><code>&lt;script&gt;window.location.href=&quot;http://www.xss.com&quot;;&lt;/script&gt;</code></pre>经过转义后就成了：<pre><code>&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;</code></pre></li></ul><p>它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。</p><ul><li>当用户需要输入 HTML 代码时：<br>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。<br>仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。</li></ul><p>更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。</p><h4 id="SQL-注入："><a href="#SQL-注入：" class="headerlink" title="SQL 注入："></a>SQL 注入：</h4><p>所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或页面请求的查询字符串，最终达到服务器执行恶意的 SQL 命令。</p><p>具体来说，它是利用现有应用程序，将(恶意) 的 SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表单中输入 (恶意) SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句。<br><strong>SQL 防护：</strong><br>1、永远不要信任用户的输入: 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。</p><p>2、永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。</p><p>3、永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</p><p>4、不要把机密信息直接存放，加密或者 hash 掉密码和敏感的信息。</p><h3 id="DDOS-攻击："><a href="#DDOS-攻击：" class="headerlink" title="DDOS 攻击："></a>DDOS 攻击：</h3><p>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。</p><p>可以打个比方：</p><p>一群恶霸试图让对面那家有着竞争关系的商铺无法正常营业，他们会采取什么手段呢？（只为举例，切勿模仿）</p><p>恶霸们扮作普通客户一直拥挤在对手的商铺，赖着不走，真正的购物者却无法进入；或者总是和营业员有一搭没一搭的东扯西扯，让工作人员不能正常服务客户；也可以为商铺的经营者提供虚假信息，商铺的上上下下忙成一团之后却发现都是一场空，最终跑了真正的大客户，损失惨重。</p><p>此外恶霸们完成这些坏事有时凭单干难以完成，需要叫上很多人一起。嗯，网络安全领域中 DoS 和 DDoS 攻击就遵循着这些思路。<br><strong>DDOS 攻击利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。</strong><br>DDoS 攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 具体有几种形式：<br>1、通过使网络过载来干扰甚至阻断正常的网络通讯；<br>2、通过向服务器提交大量请求，使服务器超负荷；<br>3、阻断某一用户访问服务器；<br>4、阻断某服务与特定系统或个人的通讯。</p><h3 id="SYN-攻击："><a href="#SYN-攻击：" class="headerlink" title="SYN 攻击："></a>SYN 攻击：</h3><p>属于 DDOS 攻击中的一种具体表现形式。</p><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。</p><p>由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>检测 SYN 攻击：检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p><blockquote><p>SYN 攻击防护：<br>1、缩短超时（SYN Timeout）时间<br>2、增加最大半连接数<br>3、过滤网关防护</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSGI</title>
      <link href="/2019/08/11/wsgi/"/>
      <url>/2019/08/11/wsgi/</url>
      
        <content type="html"><![CDATA[<h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><h3 id="WSGI简介"><a href="#WSGI简介" class="headerlink" title="WSGI简介"></a>WSGI简介</h3><p>WSGI的全称是Web Server Gateway Interface，这是一个规范，描述了web server如何与web application交互、web application如何处理请求。该规范的具体描述在PEP 3333。</p><p>注意，WSGI既要实现web server，也要实现web application。实现了WSGI的模块/库有wsgiref(python内置)、werkzeug.serving、twisted.web等，具体可见Servers which support WSGI。</p><p>当前运行在WSGI之上的web框架有Bottle、Flask、Django等，具体可见Frameworks that run on WSGI。WSGI server所做的工作仅仅是将从客户端收到的请求传递给WSGI application，然后将WSGI application的返回值作为响应传给客户端。WSGI applications 可以是栈式的，这个栈的中间部分叫做中间件，两端是必须要实现的application和server。</p><h3 id="WSGI基础"><a href="#WSGI基础" class="headerlink" title="WSGI基础"></a>WSGI基础</h3><h4 id="1-WSGI-application接口"><a href="#1-WSGI-application接口" class="headerlink" title="1.WSGI application接口"></a>1.WSGI application接口</h4><p>WSGI application接口应该实现为一个可调用对象，例如函数、方法、类、含<strong>call</strong>方法的实例。这个可调用对象可以接收2个参数：</p><p>个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env）；</p><p>一个用于发送HTTP响应状态（HTTP status ）、响应头（HTTP headers）的回调函数。</p><p>同时，可调用对象的返回值是响应正文（response body），响应正文是可迭代的、并包含了多个字符串。</p><p>WSGI application结构如下：</p><pre><code># -*- coding: utf-8 -*- # @Author : yunzedef application(environ, start_response):    response_body = &#39;Request method: %s&#39; % environ[&#39;REQUEST_METHOD&#39;]    # HTTP响应状态    status = &#39;200 OK&#39;    # HTTP响应头, 消息格式    response_headers = [        (&#39;Content-Type&#39;, &#39;text/plain&#39;),        (&#39;Content-Length&#39;, str(len(response_body)))    ]    # 将响应状态和响应头交给WSGI    start_response(status,response_headers)    # 返回响应正文    return [response_body]</code></pre><p>2.Environment<br>下面的程序可以将environment字典的内容返回给客户端（environment.py）：</p><pre><code># -*- coding: utf-8 -*- # @Author : yunzefrom wsgiref.simple_server import make_serverdef application (environ, start_response):    response_body = [       &#39;%s: %s&#39;% (key, value)  for key, value in sorted(environ.items())    ]    response_body = &#39;\n&#39;.join(response_body)    status = &#39;200 OK&#39;    response_headers = [        (&#39;Content-Type&#39;, &#39;text/plain&#39;),        (&#39;Content-Length&#39;, str(len(response_body)))    ]    start_response(status, response_headers)    return [response_body]# 实例化WSGI serverhttpd = make_server (    &#39;127.0.0.1&#39;,     8081, # port    application # WSGI application,此处就是一个函数)httpd.handle_request()print(&#39;end&#39;)</code></pre><p>浏览器（或者curl、wget等）访问<a href="http://127.0.0.1:8081/，可以看到environment的内容。" target="_blank" rel="noopener">http://127.0.0.1:8081/，可以看到environment的内容。</a><br>另外，浏览器请求一次后，environment.py就结束了，程序在终端中输出内容如下：<br><img src alt><br>3.可迭代的响应<br>如果把上面的可调用对象application的返回值：</p><pre><code>return [response_body]</code></pre><p>改成：</p><pre><code>return response_body</code></pre><p>这会导致WSGI程序的响应变慢。原因是字符串response_body也是可迭代的，它的每一次迭代只能得到1 byte的数据量，这也意味着每一次只向客户端发送1 byte的数据，直到发送完毕为止。所以，推荐使用return [response_body]。如果可迭代响应含有多个字符串，那么Content-Length应该是这些字符串长度之和：<br><img src alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker浅析</title>
      <link href="/2019/08/09/docker-qian-xi/"/>
      <url>/2019/08/09/docker-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="1、什么是docker"><a href="#1、什么是docker" class="headerlink" title="1、什么是docker"></a>1、什么是docker</h3><p><img src="https://upload-images.jianshu.io/upload_images/11624186-f73fb0efed39535d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker"></p><p>docker官方解释</p><blockquote><p>Docker是一个开源的应用引擎,让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。</p></blockquote><p>顾名思义，Docker是一个容器引擎，汽车的引擎是发动机，有了发动机，汽车才能跑起来。游戏需要游戏引擎（如Unity3D）,基于引擎的开发，能让游戏动起来~</p><blockquote><p>就如官方描述一样，Docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离、可移植的容器中，以便于发布于各种机器中而无需考虑兼容性问题~<br>这就不难解释为什么Docker的logo是一条装着一堆箱子的鲸鱼~</p></blockquote><blockquote><p>这是因为Docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个容器，容器中是我们开发的应用程序(不局限于web应用)，，每个容器都有自己独立的环境（环境设置、网络、文件系统等等），互不干扰。而每个箱子，又可以打包程一个新的镜像，放到其他服务器的Docker环境中直接运行，不需要重复安装程序运行环境~</p></blockquote><p>相关的概念：<br>1、容器<br>2、镜像<br>容器：顾名思义就是用来装东西的器皿，在Docker中容器就是装载我们应用程序的器皿，在Docker的logo中，容器就是一个个箱子。比如我们运行javaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行~</p><p>镜像：容器从哪里来，这就需要镜像了，就好比如我们装window操作系统一样，要有window镜像，因此给Docker安装容器也需要镜像，通俗一点，镜像就类似于我们日常中操作系统镜像~</p><blockquote><p>容器于镜像的关系：</p></blockquote><blockquote><p>比如我需要运行一个web应用程序，需要有一个Tomacat环境，需要一个tomcat环境，那就下载一个Tomcat解压出来，然后把Web程序放入到Tomcat的Webapps中启动即可，那么在Docker中要运行有web程序，需要有一个Tomcat环境，那就要下载一个Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中即可运行，在Docker中，容器和镜像的关系更像是动静关系，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）~</p></blockquote><blockquote><p>容器于虚拟机的比较</p></blockquote><p>Docker是一个Client-Server结构的系统，Docker守护进程（Docker daemon）运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p><p><img src="https://upload-images.jianshu.io/upload_images/11624186-45df3cc0fb93aae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker"></p><p>为什么Docker比较比VM快？<br><img src="https://upload-images.jianshu.io/upload_images/11624186-cd26482a7b0cfa93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker与虚拟机"></p><blockquote><p>docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11624186-fbfc9dcc8166cf43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容器于虚拟机的比较"></p><h3 id="2、docker的应用场景"><a href="#2、docker的应用场景" class="headerlink" title="2、docker的应用场景"></a>2、docker的应用场景</h3><p>案例1：在一次圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线了，但是一上线后发现推广海报中的中文名字乱码，领导问测试人员为什么没有做好测试，测试很委屈说我已经测试了无数遍并且测试报告都提交了，解决了所有问题才上线的，没办法只能让服务器同时查看正式服务器中的Tomacat配置，发现原来Tomcat采用了默认的编码方式:iso8859-1,而测试环境中是UTF-8.针对这个问题，项目组决定把开发环境迁移到Docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题~</p><p>案例2:<br>前几天，公司的一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代的服务器，但是准备动手迁移服务器时就麻烦了，每一台主机都需要做同样的事情~<br>1、安装jdk、Tomcat、Nginx；<br>2、配置jdk环境变量和系统变量；<br>3、配置Tomcat；<br>4、配置Nginx<br>5、安装项目所需的视频解码组件<br>6、导入项目所需的一些特殊字体<br>后面决定使用Docker部署的办法，在每台服务器都把Docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后再其他几台服务器都下载自己做的镜像，运行于Docker中，把代码上传，就OK了~</p><h3 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h3><p><strong>对于开发人员 - Build Once, Run Anywhere</strong><br>容器意味着环境隔离和可重复性。开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。另外，容器环境与所在的 Host 环境是隔离的，就像虚拟机一样，但更快更简单。</p><p><strong>对于运维人员 - Configure Once, Run Anything</strong><br>只需要配置好标准的 runtime 环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效，一致和可重复。容器消除了开发、测试、生产环境的不一致性。</p><h3 id="Docker-架构详解"><a href="#Docker-架构详解" class="headerlink" title="Docker 架构详解"></a>Docker 架构详解</h3><p>Docker 的核心组件包括：<br><strong>1、Docker 客户端 - Client</strong><br><strong>2、Docker 服务器 - Docker daemon</strong><br><strong>3、Docker 镜像 - Image</strong><br><strong>4、Registry</strong><br><strong>5、Docker 容器 - Container</strong></p><p>Docker 架构如下图所示：<br><img src alt></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker浅析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2019/08/05/git/"/>
      <url>/2019/08/05/git/</url>
      
        <content type="html"><![CDATA[<p>本文链接来源：<a href="https://my.oschina.net/dkvirus/blog/1154601" target="_blank" rel="noopener">https://my.oschina.net/dkvirus/blog/1154601</a><br>写作本篇的目的：最初我是要找 Github 相关教程的，查阅了很多资料才发现 Git 才是核心。网络上的资料大多只讲解 Git 的某个知识点，比较完整的应该是廖雪峰老师的 Git 教程，读完之后确实有所收获，但仍然能不够满意。本文以初学者的角度，循序渐进的讲解 Git 的各个知识点，以概念与实践相辅相成的方式总结一套完整的知识体系，最末尾也会加上作者最近使用 GitHub 的一些心得。希望能对初学者起到一点点的启蒙作用。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="1、初始-Git"><a href="#1、初始-Git" class="headerlink" title="1、初始 Git"></a>1、初始 Git</h3><h4 id="Git-的由来"><a href="#Git-的由来" class="headerlink" title="Git 的由来"></a>Git 的由来</h4><p>1.1、为什么需要版本控制<br>举一个简1. 为什么需要版本控制<br>举一个简单的例子，如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：单的例子，如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：<br><img src="https://github.com/lvyunze/image/raw/master/git/1.jpg" alt><br>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦.看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。更要命的是，有些部分需要你的其他同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动：<br><img src="https://github.com/lvyunze/image/raw/master/git/2.png" alt><br>tip:对每一次修改进行记录，每一次修改都是一个新的版本，这就是版本控制<br>1.2、 集中式版本控制与分布式版本控制的区别:目前市场上有两种版本控制：集中式和分布式。<br>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。<br><img src="https://github.com/lvyunze/image/raw/master/git/3.jpg" alt><br>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br><img src="https://github.com/lvyunze/image/raw/master/git/4.jpg" alt><br>1.3、Git 的诞生<br>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。<br>1.4、目前市场上的版本控制<br>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p><h3 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h3><p>由于作者使用的 window 系统，这里也就只介绍 window 下的 Git 安装。<br>1.5、下载安装包<br>上一节介绍到 Git 是由 Linus 花了一个月时间创造的，最初只在 Linux 系统上运行。由于 window 的用户很多，有大牛写了 window 版本的 Git，叫做：msysgit。（不用担心与 Git 会不会不一样，答案是一样的）<br><a href="https://pan.baidu.com/s/1gfingvL" target="_blank" rel="noopener">Git 安装程序下载</a>过程中下一步下一步即可。<br>1.6、校验是否安装成功<br>①安装成功后，在 [开始] -&gt; [所有程序] 中可以看到 [Git Bash]，这是 Git 自带的命令行工具。</p><p>②当然我们也可以使用 window 系统自带的命令行工具 [Dos]，打开 Dos 窗口后输入 git 回车会看到相关信息，也可以直接文件夹右键检验</p><h3 id="2、版本库"><a href="#2、版本库" class="headerlink" title="2、版本库"></a>2、版本库</h3><h4 id="Git-版本库理解"><a href="#Git-版本库理解" class="headerlink" title="Git 版本库理解"></a>Git 版本库理解</h4><p>2.1、什么是版本库（举例说明：在 d 盘下有个 git-demo 目录（路径：d:\git-demo）该目录下有个 .git 目录，这个 .git 目录就叫做版本库，负责管理 .git 目录所在目录 git-demo 里的文件。）<br><img src="https://github.com/lvyunze/image/raw/master/git/5.png" alt><br>2.2. 版本库的作用：版本库可以认为是一个仓库，仓库里用来放置工作空间的每一个版本信息。git-demo 目录（除了 .git 目录以外）可以认为是工作空间。最佳实践是每一次进入工作空间，不管进行多长时间的工作，修改或是删除了哪些文件，在你准备休息的时候都应该将当前工作空间放到版本库中做一次存储，也就是创建一个当前状态的版本。这个过程就好比玩网络游戏，在进入 Boss 之前对游戏设置断点存储，这样如果 Boss 打失败了，可以选择断点存储回到进入 Boss 前的那个状态。这里的断点存储就相当于将工作空间放到版本库中进行一次断点存储。如果之后对工作空间的修改并不满意，可以从版本库中找到之前存储的那个版本，替换当前工作空间即可回到上一个版本。</p><p>具体如何回滚后面一一介绍。<br>2.3. 创建版本库<br>新建一个空目录：d:\git-demo<br>打开 dos 窗口，定位到该目录下:</p><pre><code>新建一个空目录：d:\git-demo打开 dos 窗口，定位到该目录下:$ cd d:\git-demo</code></pre><p>使用 git init 指令将当前目录变成 Git 的版本库</p><pre><code>$ git init</code></pre><blockquote><p>查看是否创建成功；创建成功后，在当前目录下应该会出现一个 .git 的文件夹。如果没有看见，说明你的计算机默认将这个文件夹隐藏起来了，通过以下操作可以显示出来看到：<br><img src="https://github.com/lvyunze/image/blob/master/git/6.png" alt></p></blockquote><h4 id="版本库的设计原理"><a href="#版本库的设计原理" class="headerlink" title="版本库的设计原理"></a>版本库的设计原理</h4><blockquote><p>上一节介绍了版本库的概念，这一节介绍工作空间与版本库中是如何进行交互的。通过揣摩作者是如何设计 Git 的，来确定我们学习 Git 究竟要学习哪些东东。<br> 1.将文件添加到版本库<br>假设你已经按照 2.1 节创建了版本库，管理的目录为 d:\git-demo。</p></blockquote><blockquote><p>接下来先跟着操作一遍，有疑惑先放着，下面会根据这个例子来介绍具体过程是如何操作的。<br>在 git-demo 目录下新建文件 readme.txt<br>内容如下：（d:\git-demo\readme.txt）</p><pre><code>create a readme.txt file.</code></pre><p>打开 dos 窗口切换到 git-demo 目录下</p><pre><code>$ cd d:\git-demo</code></pre><p>输入 git status 查看状态<br>状态值：Untracked files，表示这是一个新增的文件。<br><img src="https://github.com/lvyunze/image/raw/master/git/7.png" alt><br>将 readme.txt 提交到版本库</p><pre><code>$ git commit -m &quot;add a readme.txt file&quot;</code></pre><p>输入 git status 查看状态<br>状态值：nothing to commit，表示工作空间的修改已经作为一个版本放到了版本库<br><img src="https://github.com/lvyunze/image/raw/master/git/8.png" alt><br>修改 readme.txt 文件，内容如下：（d:\git-demo\readme.txt）<br><img src="https://github.com/lvyunze/image/raw/master/git/9.png" alt></p><pre><code>create a readme.txt file.This is the second revision of the document.</code></pre><p>输入 git status 查看状态<br>状态值：Changes not staged for commit，表示版本库知道文件被修改了，只是还没有提交。<br><img src="https://github.com/lvyunze/image/raw/master/git/10.png" alt></p><ol start="2"><li>git 设计原理<br>通过上面的例子，我们有理由推测 git 在添加/修改文件到版本库中是这样操作的：<br>首先通过 git add 指令将工作区中的内容添加到暂存区；<br>再通过 git commit 指令将暂存区中内容添加到版本库中。<br><img src="https://github.com/lvyunze/image/raw/master/git/11.png1" alt></li></ol><ul><li>相关概念说明：<ul><li>工作区：git-demo 目录（除了 .git 目录以外）可以认为是工作空间</li></ul></li></ul></blockquote><ul><li><p>版本库：.git 目录可以认为是版本库，其中版本库中包含两个东东</p><ul><li>stage：叫做暂存区</li><li>master：分支，也就是真正意义上存放版本的仓库了<blockquote><p>看到上图我们不禁会想：为什么 git 的作者在设计时不直接将工作区中修改的文件直接添加到master版本库中，而要在中间再加一层 stage 暂存区呢？<br>dk 想了又想，再次做出推测：<br>抽象成思维导图就是像下面这样的：<br><img src="https://github.com/lvyunze/image/raw/master/git/12.png" alt><br>这里纠正一个错误，将 master 版本库替换成 master 分支仓库更合适。<br><img src="https://github.com/lvyunze/image/raw/master/git/13.png" alt></p></blockquote></li><li>对比上面两张思维导图，可得出如下结论：</li><li>如果小明寄快递到代收点，代收点马上就将快递送到快递公司；小红紧接着又将快递寄到代收点，代收点再次送到快递工资；与代收点在一天内收到小明、小红、小花的快递，在晚上的时候一并将快递送到快递公司。哪种看起来更好不言而喻。</li><li>版本库，作为一个仓库保存着不同版本的信息，如果每一次小修改都打一条版本信息放到版本库，那无疑会大大增加版本库的容量。最佳实践时将一定时间内的所有修改作为一条版本放到版本库中最节约资源。</li><li>如果小明寄快递到代收点，后来发现东西记错了，想要取回来，直接去代收点拿回来就可以了。如果没有代收点，小明的快递直接寄到快递公司，被快递公司放到了大货车上就不是那么容易拿回来了。放到版本库中的暂存区也就是方便你撤销你的修改。<blockquote><p>现在再回过头来看看 1 中示例代码，是不是对整个流程知根知底了，对工作区，暂存区和版本库的概念也大致熟悉了。如果不熟悉，请将本节重新阅读一遍。</p></blockquote></li></ul><ol start="3"><li>暂存区管理的是修改，不是文件<br>老的版本控制系统比如 svn，管理的是文件，也就是你每一次将本地代码提交到仓库时，实际上提交的都是文件，而文件如果一多，就会导致同步速度很慢。（使用过 svn 的应该有感受）Git 的作者考虑到这一点，舍弃了管理文件的思想，使用管理修改的新新思想，这也就是为什么使用 Git 速度很快的原因。<br>举例说明：</li></ol><ul><li>在 git-demo 目录下新建 test.txt 文件内容如下：（d:\git-demo\test.txt）<blockquote><p>this is a test.txt file.</p></blockquote></li><li>将 test.txt 文件添加到暂存区<blockquote><p>$ git add test.txt</p></blockquote></li><li>修改 test.txt 文件内容如下：<blockquote><p>this is a test.txt file.This is the second revision of the document.</p></blockquote></li><li>将 test.txt 文件提交到分支仓库<blockquote><p>$ git commit -m “add test.txt”</p></blockquote></li><li>使用 git status 查看状态<blockquote><p>$ git status<br><img src="https://github.com/lvyunze/image/raw/master/git/14.png" alt><br>我们明明 commit 了 test.txt 文件，为什么还显示有东西要提交呢？<br>我们来分析一下这个过程：<br><img src="https://github.com/lvyunze/image/raw/master/git/15.png" alt></p></blockquote></li><li>在示例代码中，第一次新增 test.txt 文件后使用 git add 把它放到了暂存区中；</li><li>第二次修改 test.txt 文件后并没有添加暂存区而直接使用 git commit 操作将暂存区中内容提交到分支仓库中。</li><li>因此，使用 git status 时可以看到仍然有一个修改，提示值：”Changes not staged for commit”也可以看出有个修改没有放到暂存区中，stated 就是暂存区的意思。</li><li>如果管理的是文件，在使用 git commit 时应该就将 test.txt 文件直接添加到版本库中。使用管理修改而不管理文件的目的是让这个过程变得更快，因为修改可以是一段描述性的字符串即可。</li></ul><ol start="4"><li>Git 我们主要学些什么<br>经过上面的学习，我们知道使用版本控制就是将本地工作区的代码在分支仓库中进行备份，而我们关心的操作就是如何从本地到暂存区到分支仓库这一条流水线的正常工作<br><img src="https://github.com/lvyunze/image/raw/master/git/16.png" alt><br>本节我们已经学习过在这条流水线上新增操作了，在接下来的章节将学习撤销操作与删除操作。<br>当然，上述三种操作可以看成是将文件塞到分支仓库，那么从分支仓库中将备份取出来也至关重要，因此，我们还要学习如何回滚版本库中指定备份。</li><li>总结</li></ol><ul><li>本节介绍了 Git 的设计原理<br>主要要掌握工作区、暂存区与分支版本库的概念。</li><li>根据设计原理确定接下来的学习路线</li><li>将本地代码备份到分支仓库流水线：工作区 - 暂存区 - 分支仓库；</li><li>已经介绍过新增操作，通过 git add 添加到暂存区，通过 git commit 提交到分支仓库；</li><li>接下来学习撤销操作和删除操作。</li><li>介绍了暂存区时管理修改而不是管理文件</li><li>学习到了三个指令</li><li>git add <filename><br>提交工作区中文件到暂存区 </filename></li><li>git commit -m <descrption><br>将暂存区中所有修改提交到分支仓库中；-m 后面紧跟着的是对当前版本的一段描述话语，方便以后再分支仓库中快速找到某个版本；注意：这里要用双引号，不能用单引号。</descrption></li><li>git status<br>查看文件/目录在 git-demo 目录下的状态，好比收快递时查的物流信息一样。<br><img src="https://github.com/lvyunze/image/raw/master/git/17.png" alt><h4 id="Git-版本回滚"><a href="#Git-版本回滚" class="headerlink" title="Git 版本回滚"></a>Git 版本回滚</h4><img src="https://github.com/lvyunze/image/raw/master/git/18.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/git/19.png" alt><br>git log 指令查看某个分支仓库中的版本信息。<blockquote><p>$ git log<br><img src="https://github.com/lvyunze/image/raw/master/git/20.png" alt><br>可以看到当前分支仓库中有两个版本，通过版本描述信息可以看到每个版本大概做了哪些修改上图中每条版本信息会包含四项内容：</p></blockquote></li><li>commit：每创建一条版本信息时，都会用 SHA1 生成一个很大的数字，并用十六进制进行表示，目的是根据这个 commit id 可以找到对应的版本信息，不会重复。</li><li>Author：提交这条版本信息的人是谁，适用于团队开发时，记录每个版本是谁提交的，这样出了问题也好找对应的负责人解决问题。</li><li>Date：这个就是提交到分支仓库的时间了。</li><li>再下面用红框框起来的东东叫做版本描述信息，如果没有它，你看到的只是一大串数字，压根不知道这条版本到底做了哪些修改。</li><li>感觉日志信息输出太多，可以使用 git log –pretty=oneline 在一行显示日志<blockquote><p>$ git log –pretty=oneline<br><img src="https://github.com/lvyunze/image/raw/master/git/21.png" alt><br>上面查看了分支仓库中有两个版本，现在在体验下版本控制工具的神奇之处，让我们将工作区回滚到第一个版本，也就是 “add a readme.txt file” 的那个版本</p></blockquote></li></ul></li><li><p>在回滚之前，先查看下当前 readme.txt 的内容：</p><pre><code>create a readme.txt file.This is the second revision of the document.today is a sunny day.</code></pre></li><li><p>使用 git reset –hard <commit id> 指令进行版本回滚</commit></p><pre><code>$ git reset --hard b4977875</code></pre><p><img src="https://github.com/lvyunze/image/raw/master/git/22.png" alt><br>说明：–hard 后面跟着的字符串是要回滚到的那条版本信息对应的 commit id，当然不需要全部写，只需要截取前面7-8位唯一标识即可。</p></li><li><p>此时再打开 readme.txt 文件，会看到内容如下：</p><pre><code>create a readme.txt file.</code></pre></li><li><p>但是，当我们再次查看历史记录时会发现分支仓库中只有一条版本信息了：<br><img src="https://github.com/lvyunze/image/raw/master/git/23.png" alt></p></li><li><p>这就很不爽了，刚才我只是测试版本库的回滚功能，并不想丢弃 “today is a sunny day” 那条版本信息。难道回不去？答案当然是不<br>使用 git reflog 指令查看刚才所有操作日志<br><img src="https://github.com/lvyunze/image/raw/master/git/24.png" alt><br>重复 git reset –hard <commit id> 就可以回到 “today ….” 的那个版本了。这里就不再赘述，自行练习即可。<br>git log 与 git reflog 的区别<br>通过上面的操作，我们看到 git log 和 git relog 好像都可以查询日志记录，那它们之间又什么区别呢？<br><img src="https://github.com/lvyunze/image/raw/master/git/25.png" alt><br>总结<br>本节介绍了版本库的基本操作，主要为查看版本库中版本信息，切换到任何你想切换的版本。</commit></p><ul><li>git log ：查看版本库版本更新日志，显示详细信息</li><li>git log –pretty=oneline：查看版本库版本更新日志，显示主要信息</li><li>git reset –hard <commit id>：回滚到指定版本</commit></li><li>git reflog：查看版本信息和回滚信息<h3 id="Git-撤销操作"><a href="#Git-撤销操作" class="headerlink" title="Git 撤销操作"></a>Git 撤销操作</h3><h4 id="场景一：在工作区乱七八糟改一通想要还原，并没有添加到暂存区。"><a href="#场景一：在工作区乱七八糟改一通想要还原，并没有添加到暂存区。" class="headerlink" title="场景一：在工作区乱七八糟改一通想要还原，并没有添加到暂存区。"></a>场景一：在工作区乱七八糟改一通想要还原，并没有添加到暂存区。</h4>在写代码的时候，如果没有提前将整个逻辑理清楚就开始修改之前的代码，那么大多数情况是到最后自己都不知道写的啥，这时候就会想要回到自己修改之前的那个版本。前提是一直在工作区进行修改，并没有添加到暂存区。<br>解决思路：<ul><li>在修改之前在分支仓库中进行一次备份</li><li>使用 git status 查询状态，如果本地工作区与分支仓库不同步（本地工作区有文件修改了咩有提交），先同步；</li><li>修改之后，不满意，只需将之前在分支仓库中的（该文件/整个目录）备份取出来替换工作区内容即可。<br><img src="/.club//25" alt><br>具体操作<pre><code>$ git checkout -- &lt;filename&gt;</code></pre></li></ul></li></ul></li></ul><pre><code>说明：由于这里没有添加到暂存区，所以该指令表示将分支仓库中的（该文件/整个目录）备份取出来替换工作区的内容。####场景二：将工作区修改过内容添加到暂存区后又对工作区文件进行修改想要还原场景二的标题有点长，拆分一下做了以下几件事情：  - 对工作区内容 readme.txt 进行修改 —— 状态1；  - 将修改后的文件 readme.txt 添加到暂存区,此时没有提交到分支仓库 —— 状态2；  - 再次对工作区内容 readme.txt 进行修改 —— 状态3。![](https://github.com/lvyunze/image/raw/master/git/26.png)现在想要将状态3撤回到原始状态，我们分析下如何做：- 状态3 撤回到状态2  - 状态2 对 readme.txt 进行修改并添加到暂存区  - 状态3 对 readme.txt 进行修改并添加到暂存区，再次修改 readme.txt</code></pre><p>// $ git checkout – <filename><br>$ git checkout – readme.txt</filename></p><pre><code>- 状态2 撤回到状态1    -状态1 对 readme.txt 进行修改    -状态2 对 readme.txt 进行修改并添加到暂存区&gt;// $ git reset HEAD &lt;filename&gt;&gt;$ git reset HEAD readme.txt- 状态1 撤回到 原始状态  - 原始状态 readme.txt 与分支仓库的备份一毛一样  - 状态1 对 readme.txt 进行修改其实到这里已经回到了场景1遇到的情况：只在工作区进行修改，并没有添加到暂存区，如何还原？</code></pre><p>// $ git checkout – <filename><br>$ git checkout – readme.txt </filename></p><pre><code>作者这里已经尽可能的把情况说的简单点，无奈言语显得有点脆弱，还需要自己实践敲一篇试验一下，记住，每次撤回到上一个状态时使用 git status 查看下当前状态。#### 场景三：在工作区修改了文件，不仅添加到了暂存区，还提交到了分支仓库中，想要还原怎么办这种情形反而更简单，提交到分支库，将相当于对当前状态做了一个备份放到分支仓库中取代了最新的备份，我们只需要将分支仓库中上一个备份取出来替代工作区内容即可。-查看分支仓库版本备份信息  &gt;$ git log --pretty=oneline  ![](https://github.com/lvyunze/image/raw/master/git/27.png)- 使用 git reset 指令回到上一个版本  &gt;$ git reset --hard 7e46747  ![](https://github.com/lvyunze/image/raw/master/git/28.png)结论  又到了总结时间，本节以实际场景触发，考虑到所有需要撤回的场景，需要多加练习。  - 场景1：修改了工作区内容没有添加到暂存区撤回操作；  - 场景2：修改了工作区添加到暂存区又修改了该文件撤回操作（详细介绍三步自操作）；  - 场景3：修改了工作区内容添加到暂存区又提交到分支仓库后撤回操作。#### 删除操作&gt;本节假设你已经创建了版本库，路径为 d:\git-demo。##### 创建测试文件，添加到版本库本节需要删除文件，先创建一个测试文件 testdel.txt 添加到版本库，方便接下来场景的测试使用。- 在 d:\git-demo 目录下创建文件 testdel.txt内容如下：&gt;this file will be deleted.- 添加到暂存区&gt;$ git add testdel.txt- 提交到版本库&gt; $ git commit -m &quot;add a testdel file&quot;- 使用 git status 查看状态&gt; $ git status场景一：在工作区删除一个文件，误操作，想要还原- 将 testdel.txt 文件删除后发现是误操作，需要找回。- 先使用 git status 查看下当前状态：![](https://github.com/lvyunze/image/raw/master/git/29.png)可以看到我们删除了文件，也被当做是一次修改，再次证实暂存区管理的是修改而不是文件。-幸运的是之前将这个文件添加到版本库中，所以我们可以从版本库中取到该文件的备份。-使用 git checkout 指令从版本库的备份中取出文件&gt;$ git checkout -- testdel.txt-再次检查下 git-demo 目录，发现刚才删除的文件被找了回来。场景二：在工作区删除一个文件，想要将版本库中该文件也删除- 现在很明确要将 testdel.txt 文件删除；- 分析需要删除两次，一次是删除工作区的该文件，一次是将版本库中最新备份中该文件删除；- 删除本地工作区的 testdel.txt 文件：到 git-demo 目录下直接删除即可；- 删除版本库中最新备份中的该文件，分两步走：   - 前面说到删除本地文件也是一个修改，将这个修改告诉暂存区；</code></pre><p>   // $ git rm <filename><br>      $ git rm testdel.txt</filename></p><pre><code>   - 将暂存区的修改提交给分支仓库</code></pre><pre><code>  $ git commit -m &quot;remove testdel.txt&quot;</code></pre><p>   ````</p><ul><li>到这里为止分支仓库中最新备份中的 testdel.txt 也就被删除了。<br>场景三：在工作区删除一个文件，版本库中也删除了该文件，后来发现又需要想要还原<br>-事情总不像想象中那么简单，已经在版本库的最新版本备份中将 testdel.txt 文件删除了，想想又后悔了；<br>-git 提供了极大的机动性，可以通过回到更久远之前的版本备份即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python打包分发工具setuptools</title>
      <link href="/2019/08/03/python-da-bao-fen-fa-gong-ju-setuptools/"/>
      <url>/2019/08/03/python-da-bao-fen-fa-gong-ju-setuptools/</url>
      
        <content type="html"><![CDATA[<h2 id="setuptools"><a href="#setuptools" class="headerlink" title="setuptools"></a>setuptools</h2><p>Python打包分发工具setuptools:曾经 Python 的分发工具是 distutils，但它无法定义包之间的依赖关系。setuptools 则是它的增强版，能帮助我们更好的创建和分发 Python 包，尤其是具有复杂依赖关系的包。其通过添加一个基本的依赖系统以及许多相关功能，弥补了该缺陷。他还提供了自动包查询程序，用来自动获取包之间的依赖关系，并完成这些包的安装，大大降低了安装各种包的难度，使之更加方便,将程序打包以后可以可以安装到自己的虚拟环境中，也可以上传到PyPI，这样非常方便大项目开发</p><h3 id="setuptools使用"><a href="#setuptools使用" class="headerlink" title="setuptools使用"></a>setuptools使用</h3><p>pip 安装：</p><pre><code>$ pip install setuptools</code></pre><p>第一个安装文件<br>在目录 learn_setup 下新建安装文件 setup.py，然后创建包 myapp 模拟要打包源码包：</p><pre><code>├── myapp│ └── __init__.py└── setup.py</code></pre><p>setup.py 文件内容如下：</p><pre><code>from setuptools import setupsetup(    name=&#39;firstApp001&#39;, # 应用名    version=&#39;0.0.1&#39;, # 版本号    packages=[&#39;myapp&#39;], # 包括在安装包内的 Python 包)</code></pre><p>使用安装文件创建 wheel<br>有了上面的 setup.py 文件，我们就可以打出各种安装包，主要分为两类：sdist 和 bdist。<br>Source distribution<br>使用 sdist 可以打包成 source distribution，支持的压缩格式有：<br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/1.png" alt><br>使用方式为：</p><pre><code>$ python setup.py sdist --formats=gztar,zip</code></pre><p>目录下便会多出 dist 和 *.egg-info 目录，dist 内保存了我们打好的包，上面命令使用 –formats 指定了打出 .tar.gz 和 .zip 包，如果不指定则如上表根据具体平台默认格式打包。<br>包的名称为 setup.py 中定义的 name, version以及指定的包格式，格式如：firstApp01-0.0.1.tar.gz。</p><p>Built distribution<br>使用 bdist 可以打出 built distribution，和源码包相比，由于预先构建好，所以安装更快：<br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/2.png" alt><br>使用上，和 sdist 一样，可以使用 –formats 指定包格式。如：</p><pre><code>$ python setup.py bdist --formats=rpm</code></pre><p>同时为了简化操作，setuptools 提供了如下命令：<br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/3.png" alt><br>所以上面打 rpm 包可以使用:</p><pre><code>$ python setup.py bdist_rpm</code></pre><p>Wheel<br>Wheel 也是一种 built 包，而且是官方推荐的打包方式。也许你曾经遇见或使用过 egg 包，但现在 <a href="https://wheel.readthedocs.io/en/stable/" target="_blank" rel="noopener">wheel</a> 是官方推荐的打包方式<br>使用 wheel 打包，首先要安装 wheel：</p><pre><code>$ pip install wheel</code></pre><p>然后使用 bdist_wheel 打包：</p><pre><code>$ python setup.py bdist_wheel</code></pre><p>执行成功后，目录下除了 dist 和 *.egg-info 目录外，还有一个 build 目录用于存储打包中间数据。<br>wheel 包的名称如 firstApp01-0.0.1-py3-none-any.whl，其中 py3 指明只支持 Python3。可以使用参数 –universal，包名如 mfirstApp-0.0.1-py2.py3-none-any.whl，表明 wheel 包同时支持 Python2 和 Python3使用 universal 也成为通用 wheel 包，反之称为纯 wheel 包。</p><p>安装 Wheel<br>上一节的示例应用没有任何内容。下面添加模块 greet 并重新打包。</p><pre><code># greet.pydef hello():    print(&#39;Hello, welcome to setuptools!&#39;)</code></pre><p>使用 bdist_wheel 再次打包后，我们可以使用 pip 安装到本地 Python 的 site-packages 目录。</p><pre><code>$ pip install dist/fisrtApp001-0.0.1-py3-none-any.whl</code></pre><p>现在和其他使用 pip 安装的三方库一样使用：</p><pre><code>from nyapp.greet import hellohello()</code></pre><p>应用开发过程中会频繁变更，每次安装都需要先卸载旧版本很麻烦。使用 develop 开发模式安装的话，实际代码不会拷贝到 site-packages 下，而是除一个指向当前应用的链接（*.egg-link）。这样当前位置的源码改动就会马上反映到 site-packages。使用如下</p><pre><code>$ pip install -e .  # 或者 python setup.py develop</code></pre><p>要是需要卸载，就使用pip uninstall<br>上传 Wheel 到 PyPI<br>Wheel 包可以自己使用和传输给其他人使用，但是维护更新不方便，而 PyPI 作为 Python 的 软件仓库，让所有人可以方便的上传和下载，以及管理三方库。</p><p>注册 PyPI 账号<br>登录 <a href="https://pypi.python.org/pypi，进入" target="_blank" rel="noopener">https://pypi.python.org/pypi，进入</a> Register 注册账号。</p><p>安装 twine虽然 setuptools 支持使用 setup.py upload 上传包文件到 PyPI，但只支持 HTTP 而被新的 twine 取代,同样的，需要先安装 twine：</p><pre><code>$ pip install twine</code></pre><p>使用 twine 上传<br>使用 upload：</p><pre><code>$ twine upload dist/*</code></pre><p>输入 username 和 password 即上传至 PyPI。如果不想每次输入账号密码，可以在家目录下创建 .pypirc 文件，内容如下：</p><pre><code>[distutils]index-servers =    pypi    pypitest[pypi]username: password: [pypitest]repository: https://test.pypi.org/legacy/username: password:</code></pre><p>填上自己的账号密码即可，这里配置了官方的 pypi 和 pypitest，若要配置其他仓库，按格式添加。回到 PyPI 主页即可看到上传的 firstApp001<br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/4.png" alt><br>setup() 参数<br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/5.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/Python%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7setuptools/6.png" alt><br>上面的 setup.py 安装文件内，我们已经使用了 setup() 一些参数：name, version, packages。<br>version<br>项目版本号，一般由三部分组成：MAJOR, MINOR, MAINTENANCE。 </p><ul><li>MAJOR version when they make incompatible API changes, </li><li>MINOR version when they add functionality in a backwards-compatible manner, and </li><li>MAINTENANCE version when they make backwards-compatible bug fixes.<br>版本号的选择参见：<a href="https://packaging.python.org/tutorials/distributing-packages/#choosing-a-versioning-scheme" target="_blank" rel="noopener">https://packaging.python.org/tutorials/distributing-packages/#choosing-a-versioning-scheme</a><br>packages:列出项目内需要被打包的所有 package。一般使用 setuptools.find_packages() 自动发现。<pre><code>packages=find_packages(exclude=[&#39;contrib&#39;, &#39;docs&#39;, &#39;tests*&#39;])# exclude 用于排除不打包的 package</code></pre>description：项目的简短描述，一般一句话就好，会显示在 PyPI 上名字下端。<pre><code>description=&#39;My first Python project&#39;</code></pre>对项目的完整描述，使用 long_description。如果此字符串是 rst 格式的，PyPI 会自动渲染成 HTML 显示。也可指定使用 markdown。<pre><code>long_description=long_description,long_description_content_type=&#39;text/x-rst&#39;</code></pre></li></ul><p>url:通常为 GitHub上 的链接或者 readthedocs 的链接。</p><pre><code>url=&#39;https://github.com/pypa/sampleproject&#39;</code></pre><p>author:作者信息</p><pre><code>author=&#39;example&#39;,author_email=&#39;example@example.com&#39;</code></pre><p>license:项目许可证</p><pre><code>license=&#39;MIT&#39;</code></pre><p>关于各种许可证的介绍和选择，参考：<a href="https://choosealicense.com/" target="_blank" rel="noopener">https://choosealicense.com/</a><br>classifiers:项目分类，完整可选项参考：<a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers" target="_blank" rel="noopener">https://pypi.python.org/pypi?%3Aaction=list_classifiers</a></p><pre><code>classifiers=[    # How mature is this project? Common values are    # 3 - Alpha    # 4 - Beta    # 5 - Production/Stable    &#39;Development Status :: 3 - Alpha&#39;,    # Indicate who your project is intended for    &#39;Intended Audience :: Developers&#39;,    &#39;Topic :: Software Development :: Build Tools&#39;,    # Pick your license as you wish (should match &quot;license&quot; above)     &#39;License :: OSI Approved :: MIT License&#39;,    # Specify the Python versions you support here. In particular, ensure    # that you indicate whether you support Python 2, Python 3 or both.    &#39;Programming Language :: Python :: 2&#39;,    &#39;Programming Language :: Python :: 2.6&#39;,    &#39;Programming Language :: Python :: 2.7&#39;,    &#39;Programming Language :: Python :: 3&#39;,    &#39;Programming Language :: Python :: 3.2&#39;,    &#39;Programming Language :: Python :: 3.3&#39;,    &#39;Programming Language :: Python :: 3.4&#39;,],</code></pre><p>keywords:项目关键词列表</p><pre><code>keywords=&#39;sample setuptools development&#39;</code></pre><p>project_urls:项目相关额外连接，如代码仓库，文档地址等。</p><pre><code>project_urls={    &#39;Documentation&#39;: &#39;https://packaging.python.org/tutorials/distributing-packages/&#39;,    &#39;Funding&#39;: &#39;https://donate.pypi.org&#39;,    &#39;Say Thanks!&#39;: &#39;http://saythanks.io/to/example&#39;,    &#39;Source&#39;: &#39;https://github.com/pypa/sampleproject/&#39;,    &#39;Tracker&#39;: &#39;https://github.com/pypa/sampleproject/issues&#39;,}</code></pre><p>install_requires:项目依赖的 Python 库，使用 pip 安装本项目时会自动检查和安装依赖。</p><pre><code>install_requires=[&#39;pyyaml&#39;]</code></pre><p>依赖的安装参考：<a href="https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files" target="_blank" rel="noopener">https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files</a><br>python_requires:指定项目依赖的 Python 版本</p><pre><code>python_requires=&#39;&gt;=3&#39;</code></pre><p>package_data:项目依赖数据文件，数据文件必须放在项目目录内且使用相对路径</p><pre><code>package_data={    &#39;myapp&#39;: [&#39;data/*.yml&#39;],}</code></pre><p>如果不指定作为目录的键为空串，则代表对所有模块操作（下例中将包含所有包内 data 目录下的 yaml 文件）：</p><pre><code>package_data={    &#39;&#39;: [&#39;data/*.yml&#39;],}</code></pre><p>data_files:如果数据文件存在于项目外，则可以使用 data_files 参数或者 MANIFEST.in 文件进行管理。如果用于源码包，则使用 MANIFEST.in；如果用于 wheel，则使用 data_files。</p><pre><code>data_files=[(‘mydata’, [‘data/conf.yml’])]</code></pre><p>上述设置将在打包 wheel 时，将 data/conf.yml 文件添加至 mydata 目录。(data_files 不能使用路径通配符)<br>此外，scripts, py_modeles, entry_points, console_scripts 等参数参考：<a href="https://packaging.python.org/tutorials/distributing-packages/#setup-args" target="_blank" rel="noopener">https://packaging.python.org/tutorials/distributing-packages/#setup-args</a><br>其他初始化文件<br>在阅读 Github 上的 Python 库时，除了最基本核心的 setup.py 文件和主程序之外，还会看到其他一些文件。本节将介绍它们的作用和使用方法。</p><p>setup.cfg<br>包含了构建时候的一些默认参数，如：</p><pre><code>[bdist_wheel]universal=1</code></pre><p>用于在使用 bdist_wheel 的时候的默认设置 –universal 参数 。</p><p>README.rst/README.md:项目说明文档，使用 reStrutruedText 可以在 PyPI 上很好的渲染，但 Markdown 则支持不够好。</p><p>MANIFEST.in:此文件在打源码包的时候告诉 setuptools 还需要额外打包哪些文件。</p><pre><code># Include the READMEinclude *.md# Include the license fileinclude LICENSE.txt# Include the data filesrecursive-include data *</code></pre><p>LICENSE.txt:项目许可说明文件<br>setuptools 默认打包的文件:README.rst/README.md、setup.cfg、MANIFEST.in<br>所以其他的文件，如 LICENSE.txt，在源码包时需要手动在 MANIFEST.in 里添加 include，在 wheel 包时需要在 setup.cfg 添加：</p><pre><code>[metadata]license_file = LICENSE.txt</code></pre><h3 id="PyPI-上传推荐配置"><a href="#PyPI-上传推荐配置" class="headerlink" title="PyPI 上传推荐配置"></a>PyPI 上传推荐配置</h3><pre><code>setup.py nameversionauthorauthor_emailurlpackagesdescriptionpackage_data/data_filessetup.cfgMANIFEST.inREADME.rstLICENSE.txt&lt;项目&gt;</code></pre><p>官网例子参考：</p><pre><code>from setuptools import setup, find_packagessetup(    name=&quot;HelloWorld&quot;,    version=&quot;0.1&quot;,    packages=find_packages(),    scripts=[&#39;say_hello.py&#39;],    # Project uses reStructuredText, so ensure that the docutils get    # installed or upgraded on the target machine    install_requires=[&#39;docutils&gt;=0.3&#39;],    package_data={        # If any package contains *.txt or *.rst files, include them:        &#39;&#39;: [&#39;*.txt&#39;, &#39;*.rst&#39;],        # And include any *.msg files found in the &#39;hello&#39; package, too:        &#39;hello&#39;: [&#39;*.msg&#39;],    },    # metadata to display on PyPI    author=&quot;Me&quot;,    author_email=&quot;me@example.com&quot;,    description=&quot;This is an Example Package&quot;,    keywords=&quot;hello world example examples&quot;,    url=&quot;http://example.com/HelloWorld/&quot;,   # project home page, if any    project_urls={        &quot;Bug Tracker&quot;: &quot;https://bugs.example.com/HelloWorld/&quot;,        &quot;Documentation&quot;: &quot;https://docs.example.com/HelloWorld/&quot;,        &quot;Source Code&quot;: &quot;https://code.example.com/HelloWorld/&quot;,    },    classifiers=[        &#39;License :: OSI Approved :: Python Software Foundation License&#39;    ]    # could also include long_description, download_url, etc.)</code></pre><p>参考：<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#" target="_blank" rel="noopener">https://setuptools.readthedocs.io/en/latest/setuptools.html#</a></p>]]></content>
      
      
      <categories>
          
          <category> python工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python打包分发工具setuptools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-docx的使用</title>
      <link href="/2019/08/01/python-docx-de-shi-yong/"/>
      <url>/2019/08/01/python-docx-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>最近接到一个需求，就是需要在word中生成黑点(黑点可以是图片的形式)，还有在特定位置插入文字，语言是使用python，便想到了python-docx<br>python-docx 依赖：behave、flake8、lxml、mock、pyparsing、pytest</p><h2 id="python-docx的作用"><a href="#python-docx的作用" class="headerlink" title="python-docx的作用"></a>python-docx的作用</h2><pre><code>python-docx is a Python library for creating and updating Microsoft Word (.docx) files.More information is available in the python-docx documentation.</code></pre><h2 id="python-docx的功能"><a href="#python-docx的功能" class="headerlink" title="python-docx的功能"></a>python-docx的功能</h2><h3 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h3><p>先来一幅官方文档的图片<br>![](https:# github.com/lvyunze/image/raw/master/python-docx%E7%9A%84%E4%BD%BF%E7%94%A8/1.png)</p><pre><code>#  代码如下,# 由例子中可以得出.python-docx的功能有：插入文档标题、插入段落、插入图片、插入表格from docx import Documentfrom docx.shared import Inchesdocument = Document()document.add_heading(&#39;Document Title&#39;, 0)p = document.add_paragraph(&#39;A plain paragraph having some &#39;)p.add_run(&#39;bold&#39;).bold = Truep.add_run(&#39; and some &#39;)p.add_run(&#39;italic.&#39;).italic = Truedocument.add_heading(&#39;Heading, level 1&#39;, level=1)document.add_paragraph(&#39;Intense quote&#39;, style=&#39;Intense Quote&#39;)document.add_paragraph(    &#39;first item in unordered list&#39;, style=&#39;List Bullet&#39;)document.add_paragraph(    &#39;first item in ordered list&#39;, style=&#39;List Number&#39;)document.add_picture(&#39;monty-truth.png&#39;, width=Inches(1.25))records = (    (3, &#39;101&#39;, &#39;Spam&#39;),    (7, &#39;422&#39;, &#39;Eggs&#39;),    (4, &#39;631&#39;, &#39;Spam, spam, eggs, and spam&#39;))table = document.add_table(rows=1, cols=3)hdr_cells = table.rows[0].cellshdr_cells[0].text = &#39;Qty&#39;hdr_cells[1].text = &#39;Id&#39;hdr_cells[2].text = &#39;Desc&#39;for qty, id, desc in records:    row_cells = table.add_row().cells    row_cells[0].text = str(qty)    row_cells[1].text = id    row_cells[2].text = descdocument.add_page_break()document.save(&#39;demo.docx&#39;)</code></pre><p>下面就具体介绍一些功能</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>1、打开文档</p><pre><code>from docx import Documentdocument = Document()document.save(&#39;test.docx&#39;)</code></pre><p>2、添加段落</p><pre><code>paragraph = document.add_paragraph(&#39;Lorem ipsum dolor sit amet.&#39;)# 在特定位置前添加段落prior_paragraph = paragraph.insert_paragraph_before(&#39;Lorem ipsum&#39;)</code></pre><p>3、标题</p><pre><code>#  添加标题document.add_heading(&#39;The REAL meaning of the universe&#39;)#  修改标题大小，有1-9种规格，如果使用 level=0 ，则会新增一个带有下划线样式的标题。document.add_heading(&#39;The role of dolphins&#39;, level=2)</code></pre><p>4、换页</p><pre><code>document.add_page_break()</code></pre><p>5、表格</p><pre><code>table = document.add_table(rows=2, cols=2) # 通过行和列的属性访问表格cell = table.cell(0, 1)cell.text = &#39;parrot, possibly dead&#39;# 也可以这样访问row = table.rows[1]row.cells[0].text = &#39;Foo bar to you.&#39;row.cells[1].text = &#39;And a hearty foo bar to you too sir!&#39;# 输出表格for row in table.rows:    for cell in row.cells:        print(cell.text)# 增加行row = table.add_row()# 设置表格样式table.style = &#39;LightShading-Accent1&#39;</code></pre><p>6、图片</p><pre><code>#  添加图片document.add_picture(&#39;image-filename.png&#39;)#  设置图片大小from docx.shared import Inchesdocument.add_picture(&#39;image-filename.png&#39;, width=Inches(1.0))</code></pre><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>设置段落对齐方式，对齐样式连接参考[WD_ALIGN_PARAGRAPH](https:# python-docx.readthedocs.io/en/latest/api/enum/WdAlignParagraph.html#wdparagraphalignment)</p><pre><code># 段落对齐方式有 左对齐 、 文字居中 、 右对齐 、 文本两端对齐等， from docx.enum.text import WD_ALIGN_PARAGRAPH# LEFT      =&gt;  左对齐# CENTER    =&gt;  文字居中# RIGHT     =&gt;  右对齐# JUSTIFY   =&gt;  文本两端对齐paragraph = document.add_paragraph(&quot;云泽云泽&quot;)paragraph_format = paragraph.paragraph_formatparagraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER</code></pre><p>设置段落缩进</p><pre><code># 设置段落缩进，可为负值，如下：from docx.shared import Inchesparagraph = document.add_paragraph(&quot;云泽云泽&quot;)paragraph_format = paragraph.paragraph_formatparagraph_format.left_indent = Inches(0.5)</code></pre><p>设置段落制表符<br>[TabStops](https:# python-docx.readthedocs.io/en/latest/api/text.html#docx.text.tabstops.TabStops)</p><p>设置段落间距<br>分为 段前 和 段后 ，设置值用 Pt 单位是 磅 ，如下：</p><pre><code>paragraph_format.space_before = Pt(18)paragraph_format.space_after = Pt(12)</code></pre><p>设置段落行距<br>当行距为 最小值 和 固定值 时，设置值单位为 磅 ，需要用 Pt ；当行距为 多倍行距 时，设置值为数值，如下：</p><pre><code>from docx.shared import Length#SINGLE         =&gt;  单倍行距（默认）#ONE_POINT_FIVE =&gt;  1.5倍行距#DOUBLE2        =&gt;  倍行距#AT_LEAST       =&gt;  最小值#EXACTLY        =&gt;  固定值#MULTIPLE       =&gt;  多倍行距paragraph.line_spacing_rule = WD_LINE_SPACING.EXACTLY #固定值paragraph_format.line_spacing = Pt(18) # 固定值18磅paragraph.line_spacing_rule = WD_LINE_SPACING.MULTIPLE #多倍行距paragraph_format.line_spacing = 1.75 # 1.75倍行间距</code></pre><p>设置段落分页<br>孤行控制<br>防止在页面顶端单独打印段落末行或在页面底端单独打印段落首行。<br>与下段同页<br>防止在选中段落与后面一段间插入分页符。<br>段中不分页<br>防止在段落中出现分页符。<br>段前分页<br>在选中段落前插入分页符。</p><pre><code>#widow_control      =&gt;  孤行控制#keep_with_next     =&gt;  与下段同页#page_break_before  =&gt;  段前分页#keep_together      =&gt;  段中不分页paragraph_format.keep_with_next = True</code></pre><p>字体操作<br>设置粗体和斜体<br>在设置粗体和斜体之前，我们先简单了解一下 段落 里的运行机制。段落包含很多块级的格式，比如缩进、行高、制表符等。每一个小片段叫做一个 [run](https:# python-docx.readthedocs.io/en/latest/api/text.html#docx.text.run.Run) ，可以对 run 设置粗体和斜体等属性。我们可以设置如下：</p><pre><code>paragraph = document.add_paragraph()paragraph.add_run(&#39;云泽云泽&#39;)paragraph.add_run(&#39;粗体&#39;).bold = Trueparagraph.add_run(&#39;和&#39;)paragraph.add_run(&#39;斜体&#39;).italic = Trueparagraph.add_run(&#39;的段落。&#39;)</code></pre><p>设置字体属性<br>对 run 设置字体、大小、颜色下划线等，更多属性请参考 [Font](https:# python-docx.readthedocs.io/en/latest/api/text.html#docx.text.run.Font) ，如下：</p><pre><code>from docx.shared import RGBColor,Pt#all_caps       =&gt;  全部大写字母#bold           =&gt;  加粗#color          =&gt;  字体颜色#complex_script =&gt;  是否为“复杂代码”#cs_bold        =&gt;  “复杂代码”加粗#cs_italic      =&gt;  “复杂代码”斜体#double_strike  =&gt;  双删除线#emboss         =&gt;  文本以凸出页面的方式出现#hidden         =&gt;  隐藏#imprint        =&gt;  印记#italic         =&gt;  斜体#name           =&gt;  字体#no_proof       =&gt;  不验证语法错误#outline        =&gt;  显示字符的轮廓#shadow         =&gt;  阴影#small_caps     =&gt;  小型大写字母#snap_to_grid   =&gt;  定义文档网格时对齐网络#strike         =&gt;  删除线#subscript      =&gt;  下标#superscript    =&gt;  上标#underline      =&gt;  下划线paragraph = document.add_paragraph()paragraph.add_run(&#39;这是一个带有&#39;)paragraph.add_run(&#39;颜色&#39;).font.color.rgb = RGBColor(54, 95, 145)paragraph.add_run(&#39;的&#39;)paragraph.add_run(&#39;大字&#39;).font.size = Pt(36)  # 字体大小设置，和word里面的字号相对应</code></pre><p>设置字符样式<br>除了设置段落样式外，还可以设置一组字符样式，比如字体、大小、颜色、粗体、斜体等，如下：</p><pre><code># 自定义样式 Emphasisparagraph = document.add_paragraph(&#39;这是一个带有&#39;)paragraph.add_run(&#39;自定义样式&#39;, &#39;Emphasis&#39;)paragraph.add_run(&#39;的段落&#39;)#  或者paragraph = document.add_paragraph(&#39;这是一个带有 &#39;)run = paragraph.add_run(&#39;自定义样式&#39;)run.style = &#39;Emphasis&#39;paragraph.add_run(&#39;的段落&#39;)</code></pre><p>[页眉和页脚](https:# python-docx.readthedocs.io/en/latest/user/hdrftr.html)<br>枚举的文档</p><p>[MSO_COLOR_TYPE](https:# python-docx.readthedocs.io/en/latest/api/enum/MsoColorType.html)<br>[MSO_THEME_COLOR_INDEX](https:# python-docx.readthedocs.io/en/latest/api/enum/MsoThemeColorIndex.html)<br>[WD_PARAGRAPH_ALIGNMENT](https:# python-docx.readthedocs.io/en/latest/api/enum/WdAlignParagraph.html)<br>[WD_BUILTIN_STYLE](https:# python-docx.readthedocs.io/en/latest/api/enum/WdBuiltinStyle.html)<br>[WD_CELL_VERTICAL_ALIGNMENT](https:# python-docx.readthedocs.io/en/latest/api/enum/WdCellVerticalAlignment.html)<br>[WD_COLOR_INDEX](https:# python-docx.readthedocs.io/en/latest/api/enum/WdColorIndex.html)<br>[WD_LINE_SPACING](https:# python-docx.readthedocs.io/en/latest/api/enum/WdLineSpacing.html)<br>[WD_ORIENTATION](https:# python-docx.readthedocs.io/en/latest/api/enum/WdOrientation.html)<br>[WD_TABLE_ALIGNMENT](https:# python-docx.readthedocs.io/en/latest/api/enum/WdRowAlignment.html)<br>[WD_ROW_HEIGHT_RULE](https:# python-docx.readthedocs.io/en/latest/api/enum/WdRowHeightRule.html)<br>[WD_SECTION_START](https:# python-docx.readthedocs.io/en/latest/api/enum/WdSectionStart.html)<br>[WD_STYLE_TYPE](https:# python-docx.readthedocs.io/en/latest/api/enum/WdStyleType.html)<br>[WD_TAB_ALIGNMENT](https:# python-docx.readthedocs.io/en/latest/api/enum/WdTabAlignment.html)<br>[WD_TAB_LEADER](https:# python-docx.readthedocs.io/en/latest/api/enum/WdTabLeader.html)<br>[WD_TABLE_DIRECTION](https:# python-docx.readthedocs.io/en/latest/api/enum/WdTableDirection.html)<br>[WD_UNDERLINE](https:# python-docx.readthedocs.io/en/latest/api/enum/WdUnderline.html)</p><p>[名词解释](https:# python-docx.readthedocs.io/en/latest/dev/analysis/index.html)</p><p>扩展：[python-docx-template](https:# docxtpl.readthedocs.io/en/latest/)<br>[github地址](https:# github.com/elapouya/python-docx-template)<br>依赖于模板引擎[jinja2](http:# docs.jinkan.org/docs/jinja2/)<br>[GitHub地址](https:# github.com/pallets/jinja)</p>]]></content>
      
      
      <categories>
          
          <category> python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python-docx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印星星探秘</title>
      <link href="/2019/07/28/da-yin-xing-xing-tan-mi/"/>
      <url>/2019/07/28/da-yin-xing-xing-tan-mi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://github.com/lvyunze/image/raw/master/%E6%89%93%E5%8D%B0%E6%98%9F%E6%98%9F%E5%B0%8F%E7%BB%86%E8%8A%82/1.png" alt><br>一开始遇到这种的题目的话<br>必须联系三个重要的属性<br>1、有多少行<br>2、有多少星号，根据行数得出星号个数<br>3、前面有多少个空格，根据行数得出空格数<br>总而言之：就是根据行数得出其他两个属性的值<br>由题目知：<br>行数i：4<br>数j：2i+1<br>前面空格数：4-i</p><p>便有了以下代码</p><pre><code>for i in range(4):    for k in range(4-i):        print(&quot; &quot;,end=&quot; &quot;)    for j in range(2*i+1):        print(&quot;*&quot;, end=&quot; &quot;)    print()</code></pre><p>那么要是想要打印这种图形颠倒过来的呢<br><img src="https://github.com/lvyunze/image/raw/master/%E6%89%93%E5%8D%B0%E6%98%9F%E6%98%9F%E5%B0%8F%E7%BB%86%E8%8A%82/2.png" alt><br>那就也要推导行数与星号个数的关系，行数与前面空格的个数关系了<br>可以知道：<br>行数i：4<br>星号个数j:要推导（第一眼看尚且看不出）<br>前面空格数:要推导<br>于是根据图形规律来：</p><table><thead><tr><th>第几行</th><th>星号个数j</th><th>前面空格数k</th></tr></thead><tbody><tr><td>0</td><td>7</td><td>0</td></tr><tr><td>1</td><td>5</td><td>1</td></tr><tr><td>2</td><td>3</td><td>2</td></tr><tr><td>3</td><td>1</td><td>3</td></tr></tbody></table><p>前面空格数：k = i<br>星号个数：j = 7-2i<br>推导方法：数学归纳法</p><table><thead><tr><th>第一</th><th>第二</th><th>第三</th><th>第四</th></tr></thead><tbody><tr><td>0</td><td>7-0=7</td><td>7-2*0=7</td><td>7-2*i=7</td></tr><tr><td>1</td><td>7-2=5</td><td>7-2*1=5</td><td>7-2*i=5</td></tr><tr><td>2</td><td>7-4=3</td><td>7-2*2=3</td><td>7-2*i=3</td></tr><tr><td>3</td><td>7-6=1</td><td>7-2*3=1</td><td>7-2*i=1</td></tr></tbody></table><p>于是有了以下代码</p><pre><code>for i in range(4):    for k in range(i):        print(&quot; &quot;,end=&quot; &quot;)    for j in range(7-2i):        print(&quot;*&quot;, end=&quot; &quot;)    print()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python小题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python九九乘法表思路小细节</title>
      <link href="/2019/07/28/python-jiu-jiu-cheng-fa-biao-si-lu-xiao-xi-jie/"/>
      <url>/2019/07/28/python-jiu-jiu-cheng-fa-biao-si-lu-xiao-xi-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/top.png" alt></p><p>开始构建一个思路</p><pre><code>for i in range(1,10):    for j in range(1,i):        print(&quot;{0} x {1} = {2}&quot;.format(i,j,i*j))</code></pre><p>打印如下<br><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/1.png" alt><br>发现连续换行，而且左侧不是1开头，也就是大小不合适,没有1x1<br>解决问题：<br>1、解决连续换行问题，使用end = ‘ ‘ 或者是end = “ “都是可以的<br>2、解决左侧不是1开头的问题，将i和j调换<br>3、j的范围改为(1,i+1)<br>于是有了以下代码</p><pre><code>for i in range(1,10):    for j in range(1,i+1):        print(&quot;{0} x {1}={2}&quot;.format(j,i,i*j),end=&quot;&quot;)</code></pre><p><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/2.png" alt><br>看到了终于不换行了，但是是全部不换行<br>还有就是两个之之间没有间隔<br>分析原因以及解决办法<br>1、全部不换行是要找到需要换行的地方，也就是每一次循环i之后需要换行，于是在有了以下代码</p><pre><code>for i in range(1,10):    for j in range(1,i+1):        print(&quot;{0} x {1}={2}&quot;.format(i,j,i*j),end=&quot;&quot;)    print()</code></pre><p><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/3.png" alt><br>2、解决间隔问题<br>原因：format默认打印后没有空格<br>解决办法可以在这里添加空格<br><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/4.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/5.png" alt></p><p>或者end中添加空格<br><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/end.png" alt><br><img src="https://github.com/lvyunze/image/raw/master/python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%86%E8%8A%82/6.png" alt><br>完整代码如下：</p><pre><code>for i in range(1,10):    for j in range(1,i+1):        print(&quot;{0} x {1}= {2} &quot;.format(j,i,i*j),end=&quot; &quot;)    print()</code></pre><p>现在快速写思路代码总结：<br>1、确定i和j的范围还有之间的关系<br>2、注意输出格式，空格、是否换行、换行的位置</p>]]></content>
      
      
      <categories>
          
          <category> python题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python小题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/28/hello-world/"/>
      <url>/2019/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python正则</title>
      <link href="/2019/07/24/python-zheng-ze/"/>
      <url>/2019/07/24/python-zheng-ze/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>漫画理解Kubernetes</title>
      <link href="/2019/07/24/man-hua-li-jie-kubernetes/"/>
      <url>/2019/07/24/man-hua-li-jie-kubernetes/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/1.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/2.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/3.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/4.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/5.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/6.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/7.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/8.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/9.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/10.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/11.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/12.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/13.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/14.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/15.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/16.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/17.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/18.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/19.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/20.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/21.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/22.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/23.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/24.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/25.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/26.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/27.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/28.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/29.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/30.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/31.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/32.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/33.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/34.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/35.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/36.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/37.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/38.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/39.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/40.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/41.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/42.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/43.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/44.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/45.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/46.jpg" alt><br><img src="https://raw.githubusercontent.com/lvyunze/image/master/%E6%BC%AB%E7%94%BB%E7%90%86%E8%A7%A3Kubernetes/47.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2019/07/23/yuan-xing-mo-shi/"/>
      <url>/2019/07/23/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/07/22/jian-zao-zhe-mo-shi/"/>
      <url>/2019/07/22/jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>建造者模式:将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示~</p><p>工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整一个过程，仅仅需要知道你最终创建的结果。所以抽象工厂模式我们得到的都是对象实例或者类簇。然而建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节，比如创建一个人，我们创建的不仅仅要得到人的实例，还要关注创建人的时候，这个人应该穿什么衣服，男的还是女的，爱好都是什么。所以说建造者模式给更加注重的是创建的细节~</p><pre><code>// 创建一位人类var Human = function(param){    this.skill = param &amp;&amp; param.skill || &#39;保密&#39;;    this.hobby = param &amp;&amp; param.hobby || &#39;保密&#39;;}// 类原型方法// prototype：原型Human.prototype = {    getSkill : function(){       return this.skill;    },    getHobby : function(){       return this.hobby;    }}// 实例化姓名类var Named = function(name){   var that = this;   // 构造器   // 构造函数解析姓名的姓与名   (function(name, that){     that.wholeName = name;     if(name.indexOf(&#39; &#39;) &gt; -1){        that.FirstName = name.slice(0, name.indexOf(&#39; &#39;));        that.secondName = name.slice(name.indexOf(&#39; &#39;));        //如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。     }   })(name, that);}//实例化职位var Work = function(work){   var that = this;   // 构造器   // 构造函数中通过传入的职位特征来设置相应职位以及描述   (function(work,that){          switch(work){             case &#39;code&#39;:               that.work = &#39;工程师&#39;;             case &#39;UI&#39;:             case &#39;UE&#39;:             case &#39;teach&#39;:                that.work = &#39;教师&#39;;                that.workDescript = &#39;分享也是一种快乐&#39;;             default:                that.work = work;                that.workDescript = &#39;对不起，我们还不清楚您所选择职位的相关描述&#39;;          }   })(work, that);}// 更换期望的职位Work.prototype.changeWork = function(work){   this.work = work;}// 添加对职位的描述Work.prototype.changeDescript = function(setence){   this.workDescript = setence;}</code></pre><p>创建一位应聘者<br>应聘者建造者<br>参数 name : 姓名(全名)<br>参数 work ：期望职位</p><pre><code>var Person = function(name, work){    // 创建应聘者缓存对象    var _person = new Human();    // 创建应聘者姓名解析对象    _person.name = new Named(name);    // 创建应聘者期望职位    _person.work = new Work(work);    // 将创建的应聘者对象返回    return _person;}var person = new Person(&#39;xiao ming&#39;, &#39;code&#39;);//测试console.log(person.skill);    //保密console.log(person.name.FirstName);  // xiaoconsole.log(person.work.work); //工程师console.log(person.work.workDescript);   //每一天在编程中度过person.work.changeDescript(&#39;更改一下职位描述!&#39;);console.log(person.work.workDescript);   //更改一下职位描述！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript设计模式 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2019/07/20/chou-xiang-gong-han-mo-shi/"/>
      <url>/2019/07/20/chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>抽象工厂模式:通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例</p><p>下面代码的作用：创建这个car类其实什么都不能做，创建时没有任何属性，然而原型上的prototype上的方法也不能使用，否则会报错。但是在继承上却很有用的，因为定义了一种类，并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错，因为大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有实现，如car类中的getPrice()和getSpedeed()方法，那么一旦用子类创建了一个对象，改对象总是应该具有一些必要的方法，但是如果这些必要的方法从父类中继承过来没有具体去重写实现，那么实例化对象便会调用父类中的这些方法，要是父类能有一个友好的提示，那么对于忘记重写子类的这些错误遗漏的避免是非常有帮助的~</p><pre class=" language-bash"><code class="language-bash">//汽车抽象类，当使用其实例对象的方法时会抛出错误var Car <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Car.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    getPrice <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>,    getSpeed <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>,<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class=" language-bash"><code class="language-bash">// 抽象工厂模式var VehicleFactory  <span class="token operator">=</span> function<span class="token punctuation">(</span>subType, superType<span class="token punctuation">)</span><span class="token punctuation">{</span>    // 判断抽线工厂中是否有该抽象类    if<span class="token punctuation">(</span>typeof VehicleFactory<span class="token punctuation">[</span>superType<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      // 缓冲类      <span class="token keyword">function</span> F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      // 继承父类属性和方法      F.prototype <span class="token operator">=</span> new VehicleFactory<span class="token punctuation">[</span>superType<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 将子类constructor指向子类      subType.constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>      // 子类原型继承“父类”      subType.prototype <span class="token operator">=</span> new F<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        // 不存在该抽象类抛出错误        throw new Error<span class="token punctuation">(</span><span class="token string">'未创建该抽象类'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>// 小汽车抽象类VehicleFactory.Car <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   this.type <span class="token operator">=</span> <span class="token string">'car'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VehicleFactory.Car.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>   getPrice <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>,   getSpeed <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>// 公交车抽象类VehicleFactory.Bus <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   this.type <span class="token operator">=</span> <span class="token string">'bus'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VehicleFactory.BUs.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>   getPrice <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>,   getPassengerNum <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>,<span class="token punctuation">}</span><span class="token punctuation">;</span>// 货车抽象类VehicleFactory.Truck <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  this.type <span class="token operator">=</span> <span class="token string">'truck'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VehicleFactory.Truck.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>  getPrice <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>,  getTrainload <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> new Error<span class="token punctuation">(</span><span class="token string">'抽象方法不能调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过抽象工厂创建子类（本例中是让子类继承父类，是对子类的扩展），所以我们需要一些产品子类，然后让子类继承相应的产品簇抽象类</p><pre class=" language-bash"><code class="language-bash">//宝马子类var BMW <span class="token operator">=</span> function<span class="token punctuation">(</span>price,speed<span class="token punctuation">)</span><span class="token punctuation">{</span>   this.price <span class="token operator">=</span> price<span class="token punctuation">;</span>   this.speed <span class="token operator">=</span> speed<span class="token punctuation">;</span><span class="token punctuation">}</span>// 抽象工厂实现对Car抽象类的继承VehicleFactory<span class="token punctuation">(</span>BMW,<span class="token string">'Car'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BMW.prototype.getPrice <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> this.price<span class="token punctuation">;</span><span class="token punctuation">}</span>BMW.prototype.getSpeed <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> this.speed<span class="token punctuation">;</span><span class="token punctuation">}</span>//兰博基尼汽车子类var Lamborghini <span class="token operator">=</span> function<span class="token punctuation">(</span>price, speed<span class="token punctuation">)</span><span class="token punctuation">{</span>   this.price <span class="token operator">=</span> price<span class="token punctuation">;</span>   this.speed <span class="token operator">=</span> speed<span class="token punctuation">;</span><span class="token punctuation">}</span>//抽象工厂实现对Car抽象类的继承VehicleFactory<span class="token punctuation">(</span>Lamborghini, <span class="token string">'Car'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Lamborghini.prototype.getPrice <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> this.price<span class="token punctuation">;</span><span class="token punctuation">}</span>Lamborghini.prototype.getSpeed <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> this.speed<span class="token punctuation">;</span><span class="token punctuation">}</span>//宇通汽车子类var YUTONG <span class="token operator">=</span> function<span class="token punctuation">(</span>price, passenger<span class="token punctuation">)</span><span class="token punctuation">{</span>  this.price <span class="token operator">=</span> price<span class="token punctuation">;</span>  this.passenger <span class="token operator">=</span> passenger<span class="token punctuation">;</span><span class="token punctuation">}</span>//抽象工厂实现对Bus抽象类的继承VehicleFactory<span class="token punctuation">(</span>YUTONG, <span class="token string">'Bus'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>YUTONG.prototype.getPassengerNum <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> this.passenger<span class="token punctuation">;</span><span class="token punctuation">}</span>//奔驰汽车子类var BenzTruck <span class="token operator">=</span> function<span class="token punctuation">(</span>price, trainLoad<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.price <span class="token operator">=</span> price<span class="token punctuation">;</span>    this.trainLoad <span class="token operator">=</span> trainLoad<span class="token punctuation">;</span><span class="token punctuation">}</span>// 抽象工厂实现对Truck抽象类的继承VehicleFactory<span class="token punctuation">(</span>BenzTruck, <span class="token string">'Truck'</span><span class="token punctuation">)</span>BenzTruck.prototype.getPrice <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> this.price<span class="token punctuation">;</span><span class="token punctuation">}</span>BenzTruck.prototype.getPrice <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> this.price<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>单例测试</p><pre class=" language-bash"><code class="language-bash">var truck <span class="token operator">=</span> new BenzTruck<span class="token punctuation">(</span>1000000, 1000<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>truck.getPrice<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>   //1000000console.log<span class="token punctuation">(</span>truck.type<span class="token punctuation">)</span><span class="token punctuation">;</span>   //truck</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript设计模式 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2019/07/19/gong-han-fang-fa-mo-shi/"/>
      <url>/2019/07/19/gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>工厂方法模式:通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。</p><p>需求：新来的一批广告资源需要投放，关于计算机培训的。一批是Java的，用于绿色字体。还有一批是PHP的，要用黄色字体，红色背景。</p><p>1、于是创建两个类，通过实例对象方式来完成这个需求</p><pre class=" language-bash"><code class="language-bash">//创建Java学科类var Java <span class="token operator">=</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>    //将内容保存在content里面以备日后使用    this.content <span class="token operator">=</span> content<span class="token punctuation">;</span>    //创建对象时，通过闭包，直接执行，将内容按需求的样式插到页面当中    <span class="token punctuation">(</span>function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>        var div <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        div.innerHTML <span class="token operator">=</span> content<span class="token punctuation">;</span>        div.style.color <span class="token operator">=</span> <span class="token string">'green'</span><span class="token punctuation">;</span>        document.getElementById<span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span>.appendChild<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>//创建PHP学科类var Php <span class="token operator">=</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">(</span>function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>        var div <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        div.innerHTML <span class="token operator">=</span> content<span class="token punctuation">;</span>        div.style.color <span class="token operator">=</span> <span class="token string">'yellow'</span><span class="token punctuation">;</span>        div.style.background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>        document.getElementById<span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>.appendChild<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、又来了一批广告，关于JavaScript的，然后根据简单工厂模式实现</p><pre class=" language-bash"><code class="language-bash">var Java <span class="token operator">=</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>  //<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">}</span>var JavaScript <span class="token operator">=</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">(</span>function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>       var div <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       div.innerHTML <span class="token operator">=</span> content<span class="token punctuation">;</span>       div.style.background <span class="token operator">=</span> <span class="token string">'pink'</span><span class="token punctuation">;</span>       document.getElementById<span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>.appendChild<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>//学科类工厂<span class="token keyword">function</span> JobFactory<span class="token punctuation">(</span>type,content<span class="token punctuation">)</span><span class="token punctuation">{</span>     switch<span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'Java'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new Java<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'php'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new Php<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'JavaScript'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new JavaScript<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span>测试案例：JobFactory<span class="token punctuation">(</span><span class="token string">'JavaScript'</span>,<span class="token string">'JavaScript哪家强'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、继续又来了一批UI学科，红色边框要是按照简单工厂模式的话，需要将简单工厂方法从重构了，不仅要添加新类，还要修改工厂函数,这就引入了工厂方法模式来解决问题。<br>工厂方法模式的本意是说将实际创建对象工作推迟到子类当中。这样核心类就成了抽象类，不过对于JavaScript不必深究，JavaScript没有像传统创建抽象类那样的方式轻易创建抽象类，所以在JavaScript中实现工厂方法模式就只是需要了解到核心思想即可。</p><p>引入安全模式类：<br>作用：屏蔽使用这对类的错误使用造成的错误，比如对于一个类（暂时成为Demo类），类是需要使用new关键字来创建，但是在使用的人来说，不知道这个对象（Demo）是一个类，在使用的时候很有可能忽略new关键字直接执行（var demo = Demo();）此时我们得到的就不是想要的结果。</p><p>//错误例子</p><pre class=" language-bash"><code class="language-bash">var Demo <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Demo.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>     show <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token string">'成功获取'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>var demo <span class="token operator">=</span> new Demo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>demo.show<span class="token punctuation">(</span><span class="token punctuation">)</span>  //成功获取var demo <span class="token operator">=</span> Demo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>demo.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //Uncaught TypeError:Cannot <span class="token function">read</span> prototype <span class="token string">'show'</span> of undefined</code></pre><p>//使用安全模式（判断这个Demo是否是一个类）</p><pre class=" language-bash"><code class="language-bash">var Demo <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   if<span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>this instanceof Demo<span class="token punctuation">))</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> new Demo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>var demo <span class="token operator">=</span> Demo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>demo.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//成功获取</code></pre><pre class=" language-bash"><code class="language-bash">var Factory  <span class="token operator">=</span> function<span class="token punctuation">(</span>type,content<span class="token punctuation">)</span><span class="token punctuation">{</span>   if<span class="token punctuation">(</span>this instanceof Factory<span class="token punctuation">)</span><span class="token punctuation">{</span>      var s <span class="token operator">=</span> new this<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> s<span class="token punctuation">;</span>   <span class="token punctuation">}</span>else<span class="token punctuation">{</span>      <span class="token keyword">return</span> new Factory<span class="token punctuation">(</span>type,content<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>// 工厂原型中设置创建所有类型数据对象的基类Factory.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>     Java <span class="token keyword">:</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>        // <span class="token punctuation">..</span><span class="token punctuation">..</span>     <span class="token punctuation">}</span>,     JavaScript <span class="token keyword">:</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>       // <span class="token punctuation">..</span>.     <span class="token punctuation">}</span>,     UI <span class="token keyword">:</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>       this.content <span class="token operator">=</span> content<span class="token punctuation">;</span>       <span class="token punctuation">(</span>function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>          var div <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          div.innerHTML <span class="token operator">=</span> content<span class="token punctuation">;</span>          div.style.border <span class="token operator">=</span> <span class="token string">'1px solid red'</span><span class="token punctuation">;</span>          document.getElementById<span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span>.appendChild<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>,     php <span class="token keyword">:</span> function<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">{</span>        // <span class="token punctuation">..</span><span class="token punctuation">..</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//这样要是想要添加新类的话，只需要写在Factory这个工厂类的原型里面就可以了添加数据var data <span class="token operator">=</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>type <span class="token keyword">:</span> <span class="token string">'JavaScript'</span>,content <span class="token keyword">:</span> <span class="token string">'Javascript哪家强'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token punctuation">{</span>type <span class="token keyword">:</span> <span class="token string">'java'</span>,content <span class="token keyword">:</span> <span class="token string">'java哪家强'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token punctuation">{</span>type <span class="token keyword">:</span> <span class="token string">'php'</span>,content <span class="token keyword">:</span> <span class="token string">'php哪家强'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token punctuation">{</span>type <span class="token keyword">:</span> <span class="token string">'UI'</span>,content <span class="token keyword">:</span> <span class="token string">'UI哪家强'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">]</span>for<span class="token punctuation">(</span>var i <span class="token operator">=</span> 6<span class="token punctuation">;</span> i <span class="token operator">>=</span>0<span class="token punctuation">;</span> i--<span class="token punctuation">)</span><span class="token punctuation">{</span>  Factory<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.type, s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript设计模式 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2019/07/19/jian-dan-gong-han-mo-shi/"/>
      <url>/2019/07/19/jian-dan-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>简单工厂模式:又叫静态工厂方法,由一个工厂对象决定创建某一种产品对象类的实例主要是用来创建同一类对象~<br>使用场合：限制在创建单一对象<br>团队项目开发不同于个人开发，其对全局变量地限制很大，所以我们应该尽可能少地创建去全局变量。对于同一类对象在不同需求中地重复使用，很多时候不需要重复创建，代码复用是面向对象的一条准则。通过对简单工厂来创建一些对象，可以让这些对象共用一些资源又有一些私有资源。</p><p>登陆模块需求：用户名输入框这里如果用户输入的内容不符合规范就定义一个警示框警示一句‘用户名不能多于16个字母或数字’~</p><p>-<br>1、于是便有了下面的代码~</p><pre class=" language-bash"><code class="language-bash">var LoginAlert <span class="token operator">=</span> function<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.content <span class="token operator">=</span> text<span class="token punctuation">;</span>  <span class="token punctuation">}</span>LoginAlert.prototype.show <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  //显示警示框<span class="token punctuation">}</span>var userNameAlert <span class="token operator">=</span> new LoginAlert<span class="token punctuation">(</span><span class="token string">"用户名不能多于16个字母或数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>userNameAlert.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、然后又来了一个需求，对于用户输入的密码，用户输入的密码错误时也提示一句“输入的密码不正确”，于是就用到了类的知识~</p><pre class=" language-bash"><code class="language-bash">var passwordAlert <span class="token operator">=</span> new LoginAlert<span class="token punctuation">(</span><span class="token string">'输入的密码不正确'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>passwordAlert.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、继续增加一个需求，用户登陆时如果用户名不存在就提示一句“您的用户名不存在，请重新输入，但是需要在警示框中添加一个注册按钮”，创建一个类这样的话以前的功能就复用不了~</p><pre class=" language-bash"><code class="language-bash">var LoginConfirm <span class="token operator">=</span> function<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.content <span class="token operator">=</span> text<span class="token punctuation">;</span><span class="token punctuation">}</span>LoginConfirm.prototype.show <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //显示确认框<span class="token punctuation">}</span>var LoginFailConfirm <span class="token operator">=</span> new LoginConfirm<span class="token punctuation">(</span><span class="token string">'您的用户名不存在，请重新输入'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LoginFailConfirm.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4、然后还有一个，登陆成功后给出一个自定义提示框，除了有确定取消按钮，也提示一句‘欢迎回来’，又是一个新类~</p><pre class=" language-bash"><code class="language-bash">var LoginPrompt <span class="token operator">=</span> function<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.content <span class="token operator">=</span>text<span class="token punctuation">;</span><span class="token punctuation">}</span>LoginPrompt.prototype.show <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //显示提示框<span class="token punctuation">}</span></code></pre><p>上述存在着LoginAlert、LoginConfirm、LoginPrompt三个类，则这个问题可以通过简单工厂来解决，也就是一种模式，因为在每次创建时都要找对应的类,太麻烦了，而且在注册（regist）模块用login前缀不太好，所以最好封装在一个函数中，这样只需要记住这个函数，然后通过这个函数就可以创建需要的对象来直接使用，不止是一个人，其他人使用的时候不需要关注这个对象到底依赖于哪一个基类，只是需要记住这个函数就可以了，这个函数通常也叫工厂函数，这种模式叫简单工厂模式。<br>通俗讲法：体育商店里面有许多体育器材，有许多体育器材的介绍，你需要哪一种体育器材，看哪些体育器材的介绍，你只是需要问售货员就好了，不需要一个一个去找~<br>于是有了下面的代码：</p><pre class=" language-bash"><code class="language-bash">//篮球基类var Basketball <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.intro <span class="token operator">=</span> <span class="token string">'篮球在美国非常流行'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Basketball.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    getMember <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       console.log<span class="token punctuation">(</span><span class="token string">'每一个队伍需要5名队员'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>,    getBallSize <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       console.log<span class="token punctuation">(</span><span class="token string">'篮球很大'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//足球基类var Football <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.intro <span class="token operator">=</span> <span class="token string">'足球在世界范围内都非常流行'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Football.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    getMember <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console.log<span class="token punctuation">(</span><span class="token string">'每一个队伍需要11名队员'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>,    getBallSize <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console.log<span class="token punctuation">(</span><span class="token string">'足球很大'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//网球基类var Tennis <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.intro <span class="token operator">=</span> <span class="token string">'每年都有需要的网球比赛'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Tennis.prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    getMember <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       console.log<span class="token punctuation">(</span><span class="token string">'每个队伍需要一名队员'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>,    getBallSize <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       console.log<span class="token punctuation">(</span><span class="token string">'网球很小'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//运动工厂var SportsFactory <span class="token operator">=</span> function<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    switch<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">case</span> <span class="token string">'NBA'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new Basketball<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">case</span> <span class="token string">'wordCup'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new Football<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">case</span> <span class="token string">'FrenchOpen'</span><span class="token keyword">:</span>          <span class="token keyword">return</span> new Tennis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>要是想要踢足球的话，只需要告诉店员要买一个足球即可。使用这个商店工厂时仅仅需要记住SportsFactory这个工厂对象即可~</p><pre class=" language-bash"><code class="language-bash">//为世界杯创建一个足球，只需要记住运动工厂SportsFactory，调用并创建var footnall  <span class="token operator">=</span> SportsFactory<span class="token punctuation">(</span><span class="token string">'wordCup'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>footnall<span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>footnall.intro<span class="token punctuation">)</span><span class="token punctuation">;</span>footnall.getMember<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>非常简单，类似地创建自定义弹框~</p><pre class=" language-bash"><code class="language-bash">var PopFactory <span class="token operator">=</span> function<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>   switch<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">case</span> <span class="token string">'alert'</span><span class="token keyword">:</span>         <span class="token keyword">return</span> new LoginAlert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">case</span> <span class="token string">'confirm'</span><span class="token keyword">:</span>         <span class="token keyword">return</span> new LoginConfirm<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">case</span> <span class="token string">'prompt'</span><span class="token keyword">:</span>         <span class="token keyword">return</span> new LoginPrompt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>一个对象也可以代替许多类<br>例子：比如想要创建一些书，那么这些书就都有一些相似的地方，比如目录、页码等。也有一些不相似的地方，如书名、出版时间、书的类型等，对于创建的对象相似的属性就像上面一样处理，对于不同的属性就要针对性地处理，比如我们将不同属性作为参数传递来处理~<br>比如下面的：</p><pre class=" language-bash"><code class="language-bash">//工厂模式<span class="token keyword">function</span> createBook<span class="token punctuation">(</span>name,time,type<span class="token punctuation">)</span><span class="token punctuation">{</span>   var o <span class="token operator">=</span> new Object<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   o.name <span class="token operator">=</span> name<span class="token punctuation">;</span>   o.time <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">;</span>   o.getName <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console.log<span class="token punctuation">(</span>this.name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>var book1 <span class="token operator">=</span> createBook<span class="token punctuation">(</span><span class="token string">"js book"</span>,2018,<span class="token string">"js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var book2 <span class="token operator">=</span> createBook<span class="token punctuation">(</span><span class="token string">"css book"</span>,<span class="token string">"2019"</span>,<span class="token string">"css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>book1.getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>book2.getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述是没有继承任何类或对象,要是想要寄生式继承的话如下</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> createPop<span class="token punctuation">(</span>type,text<span class="token punctuation">)</span><span class="token punctuation">{</span>  var 0 <span class="token operator">=</span> new Object<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  o.content <span class="token operator">=</span> text<span class="token punctuation">;</span>  o.show <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //显示方法  <span class="token punctuation">}</span><span class="token punctuation">;</span>  if<span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">'alert'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //警示框差异部分  <span class="token punctuation">}</span>  if<span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">'prompt'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //提示框差异部分  <span class="token punctuation">}</span>  if<span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">'confirm'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //确认框差异部分  <span class="token punctuation">}</span>  //将对象返回  <span class="token keyword">return</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span>//创建警示框var userNameAlert <span class="token operator">=</span> createPop<span class="token punctuation">(</span><span class="token string">'alert'</span>,<span class="token string">'用户名只能是26个字母'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript设计模式 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first</title>
      <link href="/2019/07/16/my-first/"/>
      <url>/2019/07/16/my-first/</url>
      
        <content type="html"><![CDATA[<hr><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
